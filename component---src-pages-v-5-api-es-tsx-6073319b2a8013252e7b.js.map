{"version":3,"sources":["webpack:///./src/data/es/api-v5.tsx","webpack:///./src/pages/v5/api.es.tsx"],"names":["Popup","typographyStyles","note","colors","lightPink","buttonStyles","links","codeBlock","typeText","CodeArea","useFieldArrayArgument","Api","location","defaultLang","title","api","ApiPage"],"mappings":"2QAWe,EACN,0BAOH,WA4BA,WAkBA,WAcA,WAOA,WAKA,WA0EWA,EAAA,EAWX,WAOkBC,IAAiBC,KAiCnC,WAQkBD,IAAiBC,KAUnC,WAUkBD,IAAiBC,KAYNC,IAAOC,UAMrBC,IAAaC,MAiE1B,WAkBF,WAIkBL,IAAiBC,KAwBnC,WA6BA,WAaA,WA6BE,WAoBF,WAMqBD,IAAiBM,UAKpBN,IAAiBC,KAIdD,IAAiBM,UAkDtC,WAGkBN,IAAiBC,KAkCnC,WA2BkBD,IAAiBC,KAenC,WA6BA,WAMkBD,IAAiBC,KAepBG,IAAaC,MAoBLL,IAAiBO,SAUjBP,IAAiBO,SAejBP,IAAiBO,SAajBP,IAAiBO,SAQlBP,IAAiBC,KAKjBD,IAAiBC,KAahBD,IAAiBO,SAYjBP,IAAiBO,SASjCC,EAAA,EAYgBR,IAAiBO,SAcjBP,IAAiBO,SA2BjBP,IAAiBO,SAYxC,WA6CA,WAGwBP,IAAiBO,SAKvBP,IAAiBC,KA+BZD,IAAiBO,SAUjBP,IAAiBO,SAYjBP,IAAiBO,SAUjBP,IAAiBO,SAejBP,IAAiBO,SAgBlBP,IAAiBC,KAWvC,WASkBD,IAAiBC,KASnC,WAiBGO,EAAA,EAAkBC,IAGHT,IAAiBC,KA+B5BO,EAAA,EAyCP,WAMuBR,IAAiBO,SAQlBP,IAAiBC,KAehBD,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAOlBP,IAAiBC,KAahBD,IAAiBO,SAexC,WA2BkBP,IAAiBC,KAOjBD,IAAiBC,KAKjBD,IAAiBC,KAQjBD,IAAiBC,KC/sC1BS,UAdH,SAAC,GAAD,IACVC,EADU,EACVA,SADU,OAQV,gBAAC,IAAD,CAAQA,SAAUA,EAAUC,YAAY,MACtC,gBAAC,IAAD,CAAKC,MAAOC,EAAWH,SAAUA,IACjC,gBAACI,EAAA,EAAD,CAASH,YAAY","file":"component---src-pages-v-5-api-es-tsx-6073319b2a8013252e7b.js","sourcesContent":["import * as React from \"react\"\nimport { Link as NavLink } from \"gatsby\"\nimport colors from \"../../styles/colors\"\nimport translateLink from \"../../components/logic/translateLink\"\nimport Popup from \"../../components/Popup\"\nimport CodeArea from \"../../components/CodeArea\"\nimport useFieldArrayArgument from \"../../components/codeExamples/useFieldArrayArgument\"\nimport typographyStyles from \"../../styles/typography.module.css\"\nimport buttonStyles from \"../../styles/button.module.css\"\nimport code from \"../../components/codeExamples/defaultExample\"\n\nexport default {\n  title: \"Documentación de la API\",\n  header: {\n    description: \"se enfoca en proveer la mejor DX simplificando la API.\",\n  },\n  useForm: {\n    title: \"useForm\",\n    intro: (\n      <>\n        Invocando <code>useForm</code>, recibirás los siguientes métodos{\" \"}\n      </>\n    ),\n    description: (\n      <p>\n        <code>useForm</code> también tiene argumentos <b>opcionales</b>. El\n        siguiente ejemplo muestra todos los valores de las opciones por defecto.\n      </p>\n    ),\n    validationResolver: (goToSection) => (\n      <>\n        <p>\n          Esta función de devolución de llamada le permite ejecutar cualquier\n          esquema o personalizado validación. La función tiene la forma completa\n          <code>values</code> como argumento, y deberá validar el resultado y\n          devolver ambos <code>values</code> y <code>errors</code>. Lee mas en{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"validationResolver\")}\n          >\n            validationResolver\n          </button>\n          sección.\n        </p>\n      </>\n    ),\n    validateContext: (\n      <>\n        <p>\n          This context object will be injected into{\" \"}\n          <code>validationResolver</code>'s second argument or Este objeto de\n          contexto se inyectará en El segundo argumento de{\" \"}\n          <code>validationResolver</code> o\n          <a\n            href=\"https://github.com/jquense/yup\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Yup\n          </a>\n          objeto de contexto de validación.\n        </p>\n      </>\n    ),\n    validateCriteriaMode: (\n      <>\n        <p>\n          El comportamiento predeterminado <code>firstError</code> realizará\n          todas las validaciones de los campos y reunirá los primeros errores\n          encontrados.\n        </p>\n        <p>\n          Con la configuración seteada en <code>all</code>, se correran todas\n          las validaciones de los campos y reunirá todos los errores\n          encontrados.\n        </p>\n      </>\n    ),\n    validateOnSubmit: (\n      <>\n        La validación se activará en el evento <code>submit</code> y se\n        adjuntarán event listeners en el <code>onChange</code> a los inputs\n        inválidos, para volver a validarlos.\n      </>\n    ),\n    validateOnBlur: (\n      <>\n        La validación se activará en el evento <code>blur</code>.\n      </>\n    ),\n    validateOnChange: (\n      <>\n        La validación se activará en el evento <code>change</code> de cada\n        input, lo que conducirá a multiples renderizaciones. NO es recomendado:\n        Considera que es una mala práctica de performance.\n      </>\n    ),\n    defaultValues: (goToSection) => (\n      <>\n        <p>\n          Puedes setear el valor por defecto del input con{\" \"}\n          <code>defaultValue/defaultChecked</code>{\" \"}\n          <a\n            className={buttonStyles.links}\n            href=\"https://reactjs.org/docs/uncontrolled-components.html\"\n          >\n            (lee más acerca de los valores por defecto en la documentación de\n            React)\n          </a>{\" \"}\n          o utilizando <code>defaultValues</code> como argumento opcional para\n          cargar los valores por defecto del formulario entero.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>defaultValues</code> is cached within the custom hook, if you\n          want to reset <code>defaultValues</code> please use{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"reset\")}\n          >\n            reset\n          </button>{\" \"}\n          api.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Los valores definidos\n          en <code>defaultValues</code> serán inyectados en{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"watch\")}\n          >\n            watch\n          </button>{\" \"}\n          como <code>defaultValue</code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b>{\" \"}\n          <code>defaultValues</code> no se carga automáticamente con los inputs\n          registrados manualmente (ej:{\" \"}\n          <code>{`register({ name: 'test' })`}</code>) porque el input{\" \"}\n          <code>registrado</code> manualmente no provee la{\" \"}\n          <code>referencia</code> a React Hook Form.\n        </p>\n      </>\n    ),\n    validationSchema: (goToSection) => (\n      <p>\n        Aplica reglas de validación de formularios con <code> Yup </code>\n        en el nivel de esquema, por favor refiérase a la sección{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"validationSchema\")}\n        >\n          validationSchema\n        </button>{\" \"}\n        .\n      </p>\n    ),\n    reValidateMode: (\n      <p>\n        Esta opción te permite configurar cuándo las entradas con errores son\n        revalidadas (por defecto, la validación se activa cuando se cambia un\n        input.) <Popup />\n      </p>\n    ),\n    validationFields: (\n      <p>\n        Proporcionar un array de campos significa que solo los campos incluidos\n        serán validados. Esta opción es útil cuando deseas alternar qué campos\n        son necesarios para validar.\n      </p>\n    ),\n    submitFocusError: (\n      <>\n        <p>\n          Por defecto cuando un usuario envia un formulario y este contiene\n          errores, el primer campo con un error sera el que obtenga el foco.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Solo funcionará con los\n          inputs registrados con <code>ref</code>. En los inputos registrados\n          manualmente no funcionará. ej:{\" \"}\n          <code>{`register({ name: 'test' }) // no funciona`}</code>{\" \"}\n        </p>\n      </>\n    ),\n    nativeValidation: (goToSection) => (\n      <p>\n        Seteando esta opción en <code>true</code> habilitará la validación\n        nativa del navegador. Puedes{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation\"\n        >\n          Puedes obtener más información sobre la validación nativa del\n          navegador\n        </a>\n        , y consultar la sección de{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"nativeValidation\")}\n        >\n          nativeValidation\n        </button>{\" \"}\n        para mas detalles y ejemplos.\n      </p>\n    ),\n  },\n  unregister: {\n    title: \"unregister\",\n    description: (\n      <>\n        <p>\n          Este método te permitirá <code>desregistrar</code> un input en\n          particular o un array de inputs. Esto es util cuando registras un\n          input manualmente durante <code>useEffect</code>\n          para desregistrarlo cuando se desmonte el componente.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Cuando desregistras un\n          input, su valor ya no se incluirá en los datos del formulario que se\n          envían.\n        </p>\n      </>\n    ),\n  },\n  register: {\n    title: \"register\",\n    description: (\n      <>\n        <p>\n          Este método te permite registar <code>referencias</code> de\n          inputs/select y reglas de validación en React Hook Form.\n        </p>\n        <p>\n          Las reglas de validación están basadas en el estandar HTML y también\n          permite validación personalizada.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Importante:</b> La propiedad{\" \"}\n          <code>name</code> es <b>requerida</b>y debe ser <b>unica</b>. El\n          nombre del input también permite en la sintaxis el uso de punto y\n          corchetes, lo que permite crear fácilmente campos de formulario\n          anidados. Abajo hay una tabla de ejemplo:\n        </p>\n      </>\n    ),\n    fieldArray: (\n      <p\n        style={{\n          paddingLeft: 10,\n          borderLeft: `4px solid ${colors.lightPink}`,\n        }}\n      >\n        Si estás trabajando con <code>arrays/array fields</code>, puedes asignar\n        un nombre de input como <code>name[index]</code>.{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/react-hook-form/react-hook-form/blob/master/examples/FieldArray.tsx\"\n          title=\"Ejemplo de Field Array\"\n        >\n          Consulta el ejemplo de Field Array\n        </a>\n        .\n      </p>\n    ),\n    example: \"Enviar Resultado\",\n    selectHelp:\n      \"Seleccionando la opción de registro, la tabla de API debajo se actualizará.\",\n    options: {\n      title: \"Opciones registradas\",\n      registerWithValidation: \"Registro con validación\",\n      registerWithValidationMessage:\n        \"Registro con validación y mensaje de error\",\n      note: (goToSection) => (\n        <>\n          <h2 className={typographyStyles.title}>Registro personalizado</h2>\n          <p>\n            También puedes registrar inputs manualmente, lo cual es útil cuando\n            trabajas con componentes personalizados y la referencia{\" \"}\n            <code>Ref</code>\n            no es accesible. Este es el caso cuando estas trabajando con React\n            Native o componentes personalizados como\n            <a\n              href=\"https://github.com/JedWatson/react-select\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              react-select\n            </a>\n            .\n          </p>\n\n          <p>\n            Cuando utilizas un registro personalizado, necesitarás actualizar el\n            valor del input con{\" \"}\n            <button\n              className={buttonStyles.codeAsLink}\n              onClick={() => goToSection(\"setValue\")}\n            >\n              setValue\n            </button>\n            , porque el input ya no es registrado con su referencia.\n          </p>\n\n          <p>\n            <code\n              className={typographyStyles.codeBlock}\n            >{`register({ name: 'firstName' }, { required: true, min: 8 })`}</code>\n          </p>\n\n          <p>\n            <b className={typographyStyles.note}>Nota:</b> Si quieres que el\n            input registrado manualmente dispare una renderización durante la\n            actualización de su valor, entonces necesitarás asignar un tipo a tu\n            input registrado.\n          </p>\n        </>\n      ),\n    },\n    validation: {\n      required: (\n        <>\n          Un valor booleano que, si es verdadero, indica que el input debe tener\n          un valor antes de que el formulario sea enviado. Puedes asignar una\n          cadena de texto para retornar un mensaje de error en el objeto de{\" \"}\n          <code>errores</code>.\n        </>\n      ),\n      maxLength: \"La longitud máxima del valor a aceptar para este input.\",\n      minLength: \"La longitud mínima del valor a aceptar para este input.\",\n      max: \"El valor máximo a aceptar para este input.\",\n      min: \"El valor mínimo a aceptar para este input.\",\n      pattern: \"El patrón regex para este input.\",\n      validate: `Puedes pasar una función callback commo argumento para validar, o puedes pasar un objeto de funciones callback para validar todas ellas. (consulta los ejemplos)`,\n    },\n  },\n  formState: {\n    title: \"formState\",\n    description: (\n      <>\n        <p>Este objeto contiene informacioón sobre el estado del formulario.</p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>formState</code> is wrapped with{\" \"}\n          <a\n            href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Proxy\n          </a>{\" \"}\n          to improve render performance, so make you have invoke/read it before\n          <code>render</code> in order to enable the state update. Esta La\n          función de reducción de la función de renderizado solo se aplica a la\n          plataforma web debido a una falta de soporte en <code>Proxy</code> en\n          React Native.\n        </p>\n      </>\n    ),\n    dirty:\n      \"Se setea en verdader luego que el usuario haya interactuado con algún input.\",\n    dirtyFields: \"Un conjunto único de campos modificados por el usuario.\",\n    isSubmitted:\n      \"Se setea a verdadero luego que el usuario envia el formulario. Después del envío de un formulario, su estado permanecerá enviado hasta que se invoque con el método de reinicio.\",\n    touched: \"Un objeto con todos los inputs con los que se interactuó.\",\n    isSubmitting: (\n      <>\n        Durante el envio del formulario se setea en <code>verdadero</code> y\n        luego del envio se setea en <code>falso</code>\n      </>\n    ),\n    submitCount: \"Número de envios de formulario.\",\n    isValid: \"Se setea en verdadero si no tiene ningún error.\",\n  },\n  errors: {\n    title: \"errors\",\n    description: (currentLanguage) => (\n      <>\n        <p>\n          Objeto que contiene los errores de formulario o los mensajes de error\n          que pertenecen a cada input.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Puedes aprender más en{\" \"}\n          <NavLink\n            to={translateLink(\"/advanced-usage#ErrorMessage\", currentLanguage)}\n          >\n            Mensaje de error\n          </NavLink>{\" \"}\n          de la página de uso avanzado.\n        </p>\n      </>\n    ),\n    types: (\n      <>\n        Esto es útil para validaciones de inputs como reglas de contraseña,\n        cuando múltiples errores deben retornarse para un solo campo. Para\n        habilitar esta función, asegúrese de haber configurado{\" \"}\n        <code>validateCriteriaMode: 'all'</code>.\n      </>\n    ),\n    message: `Message es un string vacio por defecto. Sin embargo, si registra la validación con un mensaje de error, se devolverá.`,\n    ref: `Referencia del input.`,\n  },\n  watch: {\n    title: \"watch\",\n    description: (\n      <>\n        <p>\n          Se observarán los inputs especificados y devolverá su valor, es útil\n          para determinar qué renderizar.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              Cuando <code>defaultValue</code> no es definido, el primer\n              renderizado de <code>watch</code> retornará <code>undefined</code>{\" \"}\n              porque es llamado antes de <code>register</code>, pero puedes\n              setear el <code>defaultValue</code> como segundo argumento para\n              retornar el valor.\n            </p>\n          </li>\n          <li>\n            <p>\n              Sin embargo, si <code>defaultValues</code> fue pasado a{\" \"}\n              <code>useForm</code> como argumento, entonces el primer\n              renderizado retornará lo que se haya definido en{\" \"}\n              <code>defaultValues</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    tableTitle: {\n      single: (\n        <>\n          Observa el valor de entrada por nombre (similar a la función {\"\"}\n          <a\n            target=\"_blank\"\n            rel=\"noreferrer noopener\"\n            href=\"https://lodash.com/docs/4.17.15#get\"\n          >\n            get\n          </a>{\" \"}\n          de lodash)\n        </>\n      ),\n      multiple: \"Observa multiples inputs\",\n      all: \"Observa todos los inputs\",\n      nest: \"Observa todos los inputs y retorna objetos anidados\",\n    },\n  },\n  handleSubmit: {\n    title: \"handleSubmit\",\n    description: (\n      <>\n        <p>\n          Esta función pasará los datos del formulario cuando la validación haya\n          sido exitosa Y puede ser invocada remotamente también.\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(onSubmit)()\n          </code>\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Puedes pasar una\n          función <code>async</code> para realizar una validación asíncrona. ej:{\" \"}\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(async (data) => await fetchAPI(data))\n          </code>\n        </p>\n      </>\n    ),\n  },\n  reset: (goToSection) => ({\n    title: \"reset\",\n    description: (\n      <>\n        <p>\n          Esta función reseteará los valores de los campos y errores dentro del\n          formulario. Al suministrar <code>omitResetState</code>, tiene la\n          libertad de solo restablece un estado específico. Puedes pasar{\" \"}\n          <code>valores</code> como argumento opcional para resetear el\n          formulario a los valores asignados.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Para componentes\n          controlados como <code>React-Select</code> que no exponen la{\" \"}\n          <code>referencia</code>, necesitarás resetear el valor del input\n          manualmente a través de{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"setValue\")}\n          >\n            setValue\n          </button>{\" \"}\n          o utilizando{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"Controller\")}\n          >\n            Controller\n          </button>{\" \"}\n          para wrappear tu componente controlado.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Necesitaras proporcione\n          <code>defaultValues</code> durante <code>useForm</code> o\n          <code>reset</code> con valor para restablecer\n          <code>Controller</code>valor de los componentes.\n        </p>\n      </>\n    ),\n  }),\n  setError: {\n    title: \"setError\",\n    description: (\n      <>\n        <p>La función te permite setear manualmente uno o varios errores.</p>\n        <p>\n          <b className={typographyStyles.note}> Nota:</b>: Este método no\n          persistirá el error y bloqueará La acción de envío. Es más útil\n          durante la función <code>handleSubmit</code> cuando desea dar\n          comentarios de error a los usuarios después de la validación\n          asíncrona.\n        </p>\n      </>\n    ),\n  },\n  clearError: {\n    title: \"clearError\",\n    description: (\n      <ul>\n        <li>\n          <p>\n            <code>undefined</code>: resetea todos los errores.\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string</code>: resetea un único error.\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string[]</code>: resetea múltiples errores.\n          </p>\n        </li>\n      </ul>\n    ),\n  },\n  setValue: {\n    title: \"setValue\",\n    description: (\n      <>\n        <p>\n          Esta función te permite setear dinámicamente los valores de\n          input/select. Al mismo tiempo, trata de evitar renderizaciones cuando\n          no son necesarias y solo bajo las siguientes condiciones:\n        </p>\n        <ul>\n          <li>\n            <p>Cuando un error es disparado por una actualización de valor.</p>\n          </li>\n          <li>\n            <p>Cuando un error es corregido por una actualización de valor.</p>\n          </li>\n          <li>\n            <p>\n              Cuando setValue es invocado por primera vez y formState{\" \"}\n              <code>dirty</code> está seteado en verdadero\n            </p>\n          </li>\n          <li>\n            <p>\n              Cuando setValue is invocado y formState <code>touched</code> es\n              actualizado.\n            </p>\n          </li>\n        </ul>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Invocando este método,{\" \"}\n          <code>formState</code> agregara el <code>name</code> del input en{\" \"}\n          <code>touched</code>.\n        </p>\n        <p>\n          También puedes setear <code>shouldValidate</code> a <code>true</code>{\" \"}\n          y esto disparará la validación del campo. ej:{\" \"}\n          <code>setValue('name', 'value', true)</code>\n        </p>\n      </>\n    ),\n  },\n  getValues: {\n    title: \"getValues\",\n    description: (\n      <>\n        <p>\n          Esta función retornará todos los datos del formulario, y es útil en\n          funciones en los que quieras retornar todo los valores del formulario.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              Por defecto <code>getValues()</code> retornará los datos del\n              formulario en una estructura plana. ej:{\" \"}\n              <code>{`{ test: 'data', test1: 'data1'}`}</code>\n            </p>\n          </li>\n          <li>\n            <p>\n              Trabajando en los campos de formulario definidos,{\" \"}\n              <code>getValues({`{ nest: true }`})</code> retornará los datos en\n              una estructura anidada de acuerdo al <code>name</code> del input.\n              ej: <code>{`{ test: [1, 2], test1: { data: '23' } }`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n  },\n  triggerValidation: {\n    title: \"triggerValidation\",\n    description: (\n      <>\n        <p>\n          Para activar manualmente una validación de input/select en el\n          formulario.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Cuando la validación\n          falla, el objeto <code>errors</code> se actualizará.\n        </p>\n      </>\n    ),\n  },\n  validationSchema: {\n    title: \"validationSchema\",\n    description: (\n      <p>\n        Si quieres centralizar tus reglas de validación con una librería de\n        validación de esquemas, puedes setear <code>validationSchema</code> en{\" \"}\n        <code>useForm</code> como argumento opcional. React Hook Form\n        actualmente soporta{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/jquense/yup\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Yup\n        </a>{\" \"}\n        para validación de esquema de objeto.\n      </p>\n    ),\n  },\n  Controller: {\n    title: \"Controller\",\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>Nombre único de tu input.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td>✓</td>\n          <td>\n            Componente controlado. ej: <code>as=\"input\"</code> or{\" \"}\n            <code>{`as={<TextInput />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>control</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td>✓</td>\n          <td>\n            El objeto <code>control</code> es obtenido al invocar{\" \"}\n            <code>useForm</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>defaultValue</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>any</code>\n          </td>\n          <td></td>\n          <td>\n            Lo mismo que el <code>defaultValue</code> de componentes no\n            controlados, cuando se setea un valor <code>booleano</code>, es\n            tratado como un checkbox input.\n            <p>\n              <b className={typographyStyles.note}>Nota:</b> necesitaras\n              proporcione <code>defaultValue</code> o\n              <code>defaultValues​​</code> en <code>useForm</code>\n            </p>\n            <p>\n              <b className={typographyStyles.note}>Note</b>: si tu formulario lo\n              hará invoque <code>reset</code> con diferentes valores, deberá\n              proporcionar <code>defaultValues​​</code> en el nivel useForm en\n              lugar de set\n              <code>defaultValue</code> en línea.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>rules</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td></td>\n          <td>\n            Reglas de validación conforme a <code>register</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChange</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (args: any | EventTarget) => any\n            </code>\n          </td>\n          <td></td>\n          <td>\n            Esta propiedad <code>onChange</code> te permitirá customizar el\n            valor de retorno, asegúrese de conocer la forma de los accesorios\n            del componente externo <code>value</code>.\n            <CodeArea\n              withOutCopy\n              rawData={`onChange={{([ event ]) => event.target.value}}\nonChange={{([ event, data ]) => ({ checked: data.checked})}}`}\n            />\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChangeName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            Esta propiedad te permite setear el nombre onChange específico del\n            objeto wrappeado, por ejemplo, cuando el evento{\" \"}\n            <code>onChange</code> se llama <code>onTextChange</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onFocus</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>() => void</code>\n          </td>\n          <td></td>\n          <td>\n            <p>\n              Esta devolución de llamada permite que el enlace personalizado se\n              centre en la entrada cuando hay un error. Esta función es\n              aplicable para React y Componentes React-Native siempre que puedan\n              enfocarse.\n            </p>\n            <p>\n              <a\n                href=\"https://codesandbox.io/s/react-hook-form-controller-auto-focus-5tru5\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                Aquí hay un ejemplo de trabajo.\n              </a>\n              .\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onBlurName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            Esta propiedad te permite setear el nombre onBlur específico del\n            objeto wrappeado, por ejemplo, cuando el evento <code>onBlur</code>\n            se llama <code>onTextBlur</code>\n          </td>\n        </tr>\n      </tbody>\n    ),\n    description: (\n      <>\n        <p>\n          React Hook Form fomenta el uso de componentes no controlados e inputs\n          nativos, sin embargo es dificil evitar trabajar con componentes\n          controlados externos como{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/JedWatson/react-select\"\n          >\n            React-Select\n          </a>\n          ,{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/ant-design/ant-design\"\n          >\n            AntD\n          </a>{\" \"}\n          y{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://material-ui.com/\"\n          >\n            Material-UI\n          </a>\n          . Este componente los envuelve para que trabajar con ellos sea más\n          sencillo.\n        </p>\n      </>\n    ),\n  },\n  useFormContext: {\n    title: \"useFormContext\",\n    introduction: (\n      <p>\n        Form context está destinado a resolver el problema cuando hay inputs\n        anidados profundamente en el árbol de componentes y pasar métodos hasta\n        el fondo como {\"\"}\n        <code> propiedades </code> se vuelve tedioso.\n      </p>\n    ),\n    description: (\n      <>\n        <p>\n          Una vez que el formulario es wrappeado con <code>FormContext</code>,\n          la <code className={typographyStyles.typeText}>function</code>{\" \"}\n          <code>useFormContext</code>\n          puede ser invocada desde sus componentes hijos.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Al invocar{\" \"}\n          <code>useFormContext</code> tendrás acceso a todas las funciones del\n          hook <code>useForm</code>.\n        </p>\n      </>\n    ),\n  },\n  control: {\n    title: \"control\",\n    description: (\n      <p>\n        Este objeto está hecho para el Controller de React Hook Form, contiene\n        métodos para registrar componentes controlados en React Hook Form.\n      </p>\n    ),\n  },\n  ErrorMessage: {\n    title: \"ErrorMessage\",\n    description: (\n      <p>\n        Un componente simple para representar el mensaje de error del input\n        asociado.\n      </p>\n    ),\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>Nombre de campo asociado.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>errors</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>object</code>\n          </td>\n          <td>✓</td>\n          <td>\n            Objeto <code>errors</code> de React Hook Form\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>message</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>mensaje de error en línea.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td></td>\n          <td>\n            Componente wrappeado o un tag HTML. ej: <code>as=\"span\"</code> o{\" \"}\n            <code>{`as={<Text />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>children</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              ({`{ message: string, messages?: string[]}`}) => any\n            </code>\n          </td>\n          <td></td>\n          <td>\n            This is a{\" \"}\n            <a\n              href=\"https://reactjs.org/docs/render-props.html\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              render prop\n            </a>{\" \"}\n            for rendering error message or messages.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> you need to set{\" \"}\n              validateCriteriaMode to 'all' for using <code>messages</code>.\n            </p>\n          </td>\n        </tr>\n      </tbody>\n    ),\n  },\n  NativeValidation: {\n    title: \"Validación nativa del navegador\",\n    description: (\n      <>\n        <p>\n          El siguiente ejemplo muestra cómo puedes aprovechar la validación\n          nativa del navegador. Solo necesitas establecer{\" \"}\n          <code>nativeValidation</code> en {\"\"}\n          <code>true</code> y el resto de la sintaxis es la misma que la\n          validación estándar.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note</b>: This feature has been\n          removed in V4 due to low usage, but you can still use it in V3\n        </p>\n      </>\n    ),\n  },\n  useFieldArray: {\n    title: \"useFieldArray\",\n    description: (\n      <>\n        <p>\n          Un hook customizado para trabajar con Field Arrays no-controlados\n          (inputs dinámicos). La razón detrás de este hook es proveer una mejor\n          experiencia de uso y performance de los formularios. Puedes mirar{\" \"}\n          <a\n            href=\"https://www.youtube.com/watch?v=Q7lrHuUfgIs\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            este corto video\n          </a>{\" \"}\n          para comparar Field Arrays controlados vs. no-controlados.\n        </p>\n\n        <p>Este hook provee el siguiente objeto y funciones.</p>\n\n        <CodeArea rawData={useFieldArrayArgument} />\n\n        <p>\n          <b className={typographyStyles.note}>Important: </b>\n          <code>useFieldArray</code> está construido sobre componentes no\n          controlados. Las siguientes notas lo ayudarán a conocer y tener en\n          cuenta su comportamiento durante la implementación.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              puedes inicializar los (campos) <code>fields</code> seteando{\" \"}\n              <code>defaultValues</code> en <code>useForm</code> hook.\n            </p>\n          </li>\n          <li>\n            <p>\n              asegurate de asignar el <code>id</code> del objeto{\" \"}\n              <code>fields</code> como la key de tu componente.\n            </p>\n          </li>\n          <li>\n            <p>\n              make sure to set <code>defaultValue</code> to{\" \"}\n              <code>fields[index]</code> when you want to set default value,\n              remove or reset with inputs.\n            </p>\n          </li>\n          <li>\n            <p>\n              no puedes llamar acciones una tras otra. Las acciones deben ser\n              activado por render.\n            </p>\n            <CodeArea\n              withOutCopy\n              rawData={`// ❌ The following is not correct\nhandleChange={() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n  append({ test: 'test' });\n}}\n\n// ✅ The following is correct and second action is triggered after next render\nhandleChange={() => {\n  append({ test: 'test' });\n}}\n\nReact.useEffect(() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n}, fields)\n            `}\n            />\n          </li>\n          <li>\n            <p>\n              It's <strong>important</strong> to apply{\" \"}\n              <code>{`ref={register()}`}</code> instead of{\" \"}\n              <code>{`ref={register}`}</code> when working with{\" \"}\n              <code>useFieldArray</code> so <code>register</code> will get\n              invoked during <code>map</code>.\n            </p>\n          </li>\n          <li>\n            <p>\n              No funciona con registro personalizado en <code>useEffect</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    table: (\n      <>\n        <tr>\n          <td>\n            <code>fields</code>\n          </td>\n          <td width={320}>\n            <code className={typographyStyles.typeText}>\n              object & {`{ id: string }`}\n            </code>\n          </td>\n          <td>\n            Este objeto es la fuente de la verdad para mapear y representar\n            entradas.\n            <p>\n              <b className={typographyStyles.note}>Importante: </b> debido a que\n              las entradas pueden ser no-controladas, se requiere{\" \"}\n              <code> id </code> con componentes mapeados para ayudar a React a\n              identificar qué elementos se han cambiado, agregado o eliminado.\n            </p>\n            <p>\n              eg: <code>{`{fields.map(d => <input key={d.id} />)}`}</code>\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>append</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (obj: object | object[]) => void\n            </code>\n          </td>\n          <td>Agregue input/inputs al final de los campos</td>\n        </tr>\n        <tr>\n          <td>\n            <code>prepend</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (obj: object | object[]) => void\n            </code>\n          </td>\n          <td>Antepone input/inputs al comienzo de tus campos</td>\n        </tr>\n        <tr>\n          <td>\n            <code>insert</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (index: number, value: object) => void\n            </code>\n          </td>\n          <td>Inserta input/inputs en una posición en particular.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>swap</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (from: number, to: number) => void\n            </code>\n          </td>\n          <td>Intercambia las posiciones de los input/inputs.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>move</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (from: number, to: number) => void\n            </code>\n          </td>\n          <td>\n            Mueve los input/inputs a otra posición.\n            <p>\n              <b className={typographyStyles.note}>Nota:</b> la diferencia entre{\" \"}\n              <code>move</code> y <code>swap</code>, si continuas llamando a{\" \"}\n              <code>move</code> pusheara input/inputs en circulo, mientras que{\" \"}\n              <code>swap</code> solo intercambiará las posiciones de dos\n              input/inputs.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>remove</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (index?: number | number[]) => void\n            </code>\n          </td>\n          <td>\n            Elimina input/inputs en una posición en particular, or elimina todos\n            cuando no se proporciona un index.\n          </td>\n        </tr>\n      </>\n    ),\n  },\n  validationResolver: {\n    title: \"validationResolver\",\n    description: (\n      <>\n        <p>\n          Esta función le permite ejecutar cualquier método de validación\n          externo, tal como{\" \"}\n          <a\n            href=\"https://github.com/hapijs/joi\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Joi\n          </a>\n          ,{\" \"}\n          <a\n            href=\"https://github.com/ianstormtaylor/superstruct\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Superstruct\n          </a>{\" \"}\n          y etc. De hecho, el objetivo no es solo limitado Sí como nuestro\n          externo (esquema) biblioteca de validación. Nos gustaría apoyar a\n          muchos otros bibliotecas de validación para trabajar con React Hook\n          Form. Incluso puedes escribir su lógica de validación personalizada\n          para validar.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> asegúrate de que eres\n          devolver objeto que contiene <code>values</code> y <code>errors</code>\n          , y su valor predeterminado debe ser un objeto vacío{\" \"}\n          <code> {`{}`} </code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> errores de retorno La\n          clave del objeto debe ser relevante para sus entradas.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> esta función se\n          almacenará en caché dentro del enlace personalizado, similar a{\" \"}\n          <code>validationSchema</code>, mientras que{\" \"}\n          <code>validationContext</code> es un objeto mutable que se puede\n          cambiar en cada representación.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> volver a validar la\n          entrada solo ocurre un campo a la vez durante la interacción del\n          usuario, porque el lib mismo evaluará el objeto de error en el campo\n          específico y desencadenar re-renderizar en consecuencia.\n        </p>\n      </>\n    ),\n  },\n}\n","import * as React from \"react\"\nimport Layout from \"../../components/layout\"\nimport Seo from \"../../components/seo\"\nimport ApiPage from \"../../components/ApiPage\"\nimport api from \"../../data/es/api-v5\"\n\nconst Api = ({\n  location,\n}: {\n  location: {\n    search: string\n    pathname: string\n  }\n}) => (\n  <Layout location={location} defaultLang=\"en\">\n    <Seo title={api.title} location={location} />\n    <ApiPage defaultLang=\"en\" />\n  </Layout>\n)\n\nexport default Api\n"],"sourceRoot":""}