{"version":3,"sources":["webpack:///./src/data/kr/api-v5.tsx","webpack:///./src/pages/v5/api.kr.tsx"],"names":["Popup","typographyStyles","note","colors","lightPink","buttonStyles","links","codeBlock","typeText","CodeArea","useFieldArrayArgument","Api","location","defaultLang","title","api","ApiPage"],"mappings":"+PAUe,EACN,UAOH,WAuBA,WAsBA,WAYA,WAOA,WAKA,WAuEGA,EAAA,EAUH,WAOkBC,IAAiBC,KAgCnC,WAOkBD,IAAiBC,KAUnC,WAUkBD,IAAiBC,KAWNC,IAAOC,UAMrBC,IAAaC,MA2D1B,WAgBF,WAIkBL,IAAiBC,KAsBnC,WA2CA,WAaA,WA2BE,WAoBF,WAMqBD,IAAiBM,UAKpBN,IAAiBC,KAIdD,IAAiBM,UAgDtC,WAMkBN,IAAiBC,KAiCnC,WAyBkBD,IAAiBC,KAenC,WA4BA,WAGkBD,IAAiBC,KAcpBG,IAAaC,MAoBLL,IAAiBO,SAUjBP,IAAiBO,SAejBP,IAAiBO,SAcjBP,IAAiBO,SAQlBP,IAAiBC,KAKjBD,IAAiBC,KAYhBD,IAAiBO,SAYjBP,IAAiBO,SAWjCC,EAAA,EAYgBR,IAAiBO,SAcjBP,IAAiBO,SA2BjBP,IAAiBO,SAcjBP,IAAiBO,SAYxC,WA2CA,WAGqBP,IAAiBO,SAIpBP,IAAiBC,KA6BZD,IAAiBO,SAUjBP,IAAiBO,SAajBP,IAAiBO,SAUjBP,IAAiBO,SAejBP,IAAiBO,SAgBlBP,IAAiBC,KAWvC,WAOkBD,IAAiBC,KASnC,WAgBGO,EAAA,EAAkBC,IAGHT,IAAiBC,KA+B5BO,EAAA,EAwCP,WAMuBR,IAAiBO,SAQlBP,IAAiBC,KAehBD,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAOlBP,IAAiBC,KAahBD,IAAiBO,SAexC,WAyBkBP,IAAiBC,KAMjBD,IAAiBC,KAIjBD,IAAiBC,KAMjBD,IAAiBC,KCjsC1BS,UAdH,SAAC,GAAD,IACVC,EADU,EACVA,SADU,OAQV,gBAAC,IAAD,CAAQA,SAAUA,EAAUC,YAAY,MACtC,gBAAC,IAAD,CAAKC,MAAOC,EAAWH,SAAUA,IACjC,gBAACI,EAAA,EAAD,CAASH,YAAY","file":"component---src-pages-v-5-api-kr-tsx-8e733549088d1955f5e1.js","sourcesContent":["import * as React from \"react\"\nimport colors from \"../../styles/colors\"\nimport Popup from \"../../components/Popup\"\nimport generic from \"../generic\"\nimport CodeArea from \"../../components/CodeArea\"\nimport useFieldArrayArgument from \"../../components/codeExamples/useFieldArrayArgument\"\nimport typographyStyles from \"../../styles/typography.module.css\"\nimport buttonStyles from \"../../styles/button.module.css\"\nimport code from \"../../components/codeExamples/defaultExample\"\n\nexport default {\n  title: \"API 설명서\",\n  header: {\n    description: \"은 API 단순화를 통해 최고의 DX를 제공합니다.\",\n  },\n  useForm: {\n    title: \"useForm\",\n    intro: (\n      <>\n        <code>useForm</code> 을 호출하여 다음의 메소드들을 사용할 수 있습니다..{\" \"}\n      </>\n    ),\n    validationResolver: (goToSection) => (\n      <>\n        <p>\n          이 콜백 함수는 어떠한 스키마나 커스텀 유효성 검사 함수를 끼워넣어\n          실행시킬 수 있도록 합니다. 이 함수는 전체 폼의 <code>values</code> 를\n          인자로 가지고 있으며, 결과를 검증한 다음\n          <code>values</code> 와 <code>errors</code> 값 모두를 리턴해야 합니다.\n          자세한 내용은\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"validationResolver\")}\n          >\n            validationResolver\n          </button>{\" \"}\n          섹션에서 확인하세요.\n        </p>\n      </>\n    ),\n    validateContext: (\n      <>\n        <p>\n          이 컨텍스트 객체는 <code>validationResolver</code> 의 두 번째 인자로\n          주입되거나{\" \"}\n          <a\n            href=\"https://github.com/jquense/yup\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Yup\n          </a>{\" \"}\n          유효성 검사의 컨텍스트 객체로 주입됩니다.\n        </p>\n      </>\n    ),\n    description: (\n      <p>\n        <code>useForm</code> 에서는 <b>옵셔널</b>한 인수도 있습니다. 다음 예제는\n        모든 옵션의 기본값을 보여줍니다.\n      </p>\n    ),\n    validateCriteriaMode: (\n      <>\n        <p>\n          기본값으로 설정 된 <code>firstError</code> 는 모든 필드 유효성 검사를\n          실행하고 처음 발견하는 모든 에러를 모읍니다.\n        </p>\n        <p>\n          <code>all</code> 로 설정하면, 모든 필드의 유효성 검사가 실행되면서\n          발생하는 필드의 모든 에러를 모읍니다.\n        </p>\n      </>\n    ),\n    validateOnSubmit: (\n      <>\n        유효성 검사는 <code>submit</code> 이벤트에서 트리거되며, 유효하지 않은\n        입력은 <code>onChange</code> 이벤트 리스너를 연결하여 유효성을 다시\n        확인합니다.\n      </>\n    ),\n    validateOnBlur: (\n      <>\n        <code>blur</code> 이벤트에서 유효성 검사가 트리거됩니다.\n      </>\n    ),\n    validateOnChange: (\n      <>\n        유효성 검사는 각 입력창의 <code>change</code> 이벤트로 시작되어, 여러번\n        다시 렌더링합니다. 이 방법은 랜더링 성능을 떨어뜨리므로 추천하지\n        않습니다.\n      </>\n    ),\n    defaultValues: (goToSection) => (\n      <>\n        <p>\n          입력의 기본값을 <code>defaultValue/defaultChecked</code> 로 설정\n          하거나{\" \"}\n          <a\n            className={buttonStyles.links}\n            href=\"https://ko.reactjs.org/docs/uncontrolled-components.html\"\n          >\n            (기본값에 대한 React 문서를 읽어보세요)\n          </a>\n          , <code>defaultValues</code> 를 옵셔널 인수로 전달 하여 전체 폼의\n          기본값을 채울 수 있습니다.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>defaultValues</code> is cached within the custom hook, if you\n          want to reset <code>defaultValues</code> please use{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"reset\")}\n          >\n            reset\n          </button>{\" \"}\n          api.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>참고:</b>{\" \"}\n          <code>defaultValues</code> 내 정의 된 값은{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"watch\")}\n          >\n            watch\n          </button>{\" \"}\n          의 <code>defaultValue</code> 값으로 주입됩니다.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 수동{\" \"}\n          <code>register</code> 필드는 React Hook Form의 <code>ref</code> 를\n          제공하지 않기에, 수동 입력 필드(예를 들어,{\" \"}\n          <code>{`register({ name: 'test' })`}</code> )의{\" \"}\n          <code>defaultValues</code> 는 자동 완성 되지 않습니다.\n        </p>\n      </>\n    ),\n    validationSchema: (goToSection) => (\n      <p>\n        <code>Yup</code> 의 스키마 레벨 폼 유효성 검사 규칙을 적용 하세요.{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"validationSchema\")}\n        >\n          validationSchema\n        </button>{\" \"}\n        섹션을 참고하세요.\n      </p>\n    ),\n    reValidateMode: (\n      <p>\n        이 옵션을 사용하여 입력의 재유효성 검사를 언제 할지 설정 할 수 있습니다.\n        (기본적으로 입력이 변경될 때 유효성 검사가 트리거 됩니다. )\n        <Popup />\n      </p>\n    ),\n    validationFields: (\n      <p>\n        제공되는 필드 배열은 앞으로 검증될 필드만 포함합니다. 이 옵션은 유효성\n        검사가 필요한 필드에 대해서 토글(toggle)을 원할 경우에 유용합니다.\n      </p>\n    ),\n    submitFocusError: (\n      <>\n        <p>\n          기본적으로 사용자가 폼을 제출하고 에러가 있는 경우, 에러가 있는 첫번째\n          필드에 포커스 됩니다.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>참고:</b> <code>ref</code> 로\n          등록된 필드만 작동합니다. 수동으로 등록하면 동작하지 않습니다. 예 :{\" \"}\n          <code>{`register({ name: 'test' }) // 동작하지 않음`}</code>{\" \"}\n        </p>\n      </>\n    ),\n    nativeValidation: (goToSection) => (\n      <p>\n        이 옵션을 <code>true</code> 로 설정하면 브라우저의 기본 유효성 검사가\n        활성화됩니다.\n        {\"  \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation\"\n        >\n          브라우저 기본 유효성 검사\n        </a>\n        에 대한 내용을 확인하시고 좀 더 자세한 내용과 예시는{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"nativeValidation\")}\n        >\n          nativeValidation\n        </button>{\" \"}\n        에서 참고하실 수 있습니다.\n      </p>\n    ),\n  },\n  unregister: {\n    title: \"unregister\",\n    description: (\n      <>\n        <p>\n          이 함수로 단일 입력 혹은 여러 입력들을 <code>unregister</code> 할 수\n          있습니다. 이 함수는 <code>useEffect</code> 로 입력을 등록한 뒤,\n          컴포넌트가 언마운트 되면서 등록을 해제하고자 할 때 유용합니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 입력을 등록\n          취소(unregister)하면, 제출된 폼 데이터에 해당 값이 더 이상 포함되지\n          않습니다.\n        </p>\n      </>\n    ),\n  },\n  register: {\n    title: \"register\",\n    description: (\n      <>\n        <p>\n          이 함수에서 입력/선택(input/select) <code>Ref</code> 와 유효성 검사\n          규칙을 등록(register)할 수 있습니다.\n        </p>\n        <p>\n          유효성 검사 규칙은 모두 HTML 표준을 기반으로 하며, 커스텀 유효성\n          검사도 가능합니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>중요:</b> <code>name</code>은{\" \"}\n          <b>필수</b>이며 <b>유니크</b>\n          해야합니다. name은 점(dot)과 괄호 구문도 지원하므로, 중첩 된 폼 필드를\n          쉽게 만들 수 있습니다. 예제는 다음과 같습니다.\n        </p>\n      </>\n    ),\n    fieldArray: (\n      <p\n        style={{\n          paddingLeft: 10,\n          borderLeft: `4px solid ${colors.lightPink}`,\n        }}\n      >\n        <code>arrays/array</code> 필드의 경우, <code>name[index]</code> 와 같이\n        name을 지정할 수 있습니다.{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/react-hook-form/react-hook-form/blob/master/examples/FieldArray.tsx\"\n          title=\"example for Field Array\"\n        >\n          Field Array 예제를 확인하세요.\n        </a>\n        .\n      </p>\n    ),\n    example: \"제출 결과\",\n    selectHelp:\n      \"등록 옵션(Register Options)을 선택하면, 아래의 API 테이블이 업데이트됩니다.\",\n    options: {\n      title: \"Register Options\",\n      registerWithValidation: \"유효성 검사와 함께 등록\",\n      registerWithValidationMessage: \"유효성 검사 및 에러 메시지 등록\",\n      note: (goToSection) => (\n        <>\n          <h2 className={typographyStyles.title}>Custom Register</h2>\n          <p>\n            커스텀 컴포넌트와 <code>Ref</code>에 액세스 할 수 없는 경우, 입력을\n            수동으로 등록 할 수 있습니다. 이는 실제로 React Native 또는{\" \"}\n            <a\n              href=\"https://github.com/JedWatson/react-select\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              react-select\n            </a>{\" \"}\n            와 같은 커스텀 컴포넌트와 작업할 때 사용될 수 있습니다.\n          </p>\n\n          <p>\n            Custome register를 사용하면, 입력은 더이상 ref로 등록되지 않으므로,{\" \"}\n            <button\n              className={buttonStyles.codeAsLink}\n              onClick={() => goToSection(\"setValue\")}\n            >\n              setValue\n            </button>{\" \"}\n            을 통해 입력 값을 업데이트해 주어야 합니다.\n          </p>\n\n          <p>\n            <code\n              className={typographyStyles.codeBlock}\n            >{`register({ name: 'firstName' }, { required: true, min: 8 })`}</code>\n          </p>\n\n          <p>\n            <b className={typographyStyles.note}>참고:</b> 값을 업데이트하는\n            동안 커스텀 등록된 입력을 다시 렌더링 하도록 하려면, 등록된 입력의\n            타입을 지정해 주어야 합니다.\n          </p>\n        </>\n      ),\n    },\n    validation: {\n      required: (\n        <>\n          폼 제출을 위해 반드시 필요한 경우, true로 지정합니다. 에러시 반환할\n          문자열 메세지는 <code>errors</code> 객체에 지정할수 있습니다.\n        </>\n      ),\n      maxLength: \"입력에 허용되는 최대 길이입니다.\",\n      minLength: \"입력에 허용되는 최소 길이입니다.\",\n      max: \"입력에 허용되는 최대 값입니다.\",\n      min: \"입력에 허용되는 최소 값입니다.\",\n      pattern: \"입력에 대한 정규식 패턴입니다.\",\n      validate: `콜백 함수를 인수로 전달하거나 콜백 함수의 객체를 전달하여 검증할 수 있습니다. (예제 참조)`,\n    },\n  },\n  formState: {\n    title: \"formState\",\n    description: (\n      <>\n        <p>폼 상태(form state)에 대한 정보를 포함합니다</p>\n\n        <p>\n          <b className={typographyStyles.note}>중요:</b> <code>formState</code>{\" \"}\n          는 랜더링 퍼포먼스 향상을 위해{\" \"}\n          <a\n            href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Proxy\n          </a>{\" \"}\n          로 감싸져 있습니다. 그러니 상태를 업데이트 하려면 <code>render</code>{\" \"}\n          전에 읽거나 실행해야 합니다. 이 다시 렌더링 기능 생략 기능은 웹\n          플랫폼에만 적용됩니다. React Native에서 <code>Proxy</code>를\n          지원합니다.\n        </p>\n      </>\n    ),\n    dirty: \"사용자가 어떠한 입력이라도 했다면, true로 설정하십시오.\",\n    dirtyFields: \"고유 한 사용자 수정 필드 세트.\",\n    isSubmitted:\n      \"사용자가 폼을 제출 한 후 true로 설정하십시오. 양식을 제출 한 후 reset 메소드로 호출 될 때까지 해당 상태가 제출 된 상태로 유지됩니다.\",\n    touched: \"상호 작용된 모든 입력의 배열입니다.\",\n    isSubmitting: (\n      <>\n        폼 제출하는 동안은 <code>true</code> 로, 그 후에는 <code>false</code>로\n        설정합니다.\n      </>\n    ),\n    submitCount: \"제출 한 폼의 수\",\n    isValid: \"에러가 없다면, true로 설정하세요.\",\n  },\n  errors: {\n    title: \"errors\",\n    description: (currentLanguage) => (\n      <>\n        <p>각 입력에 대한 폼 에러 혹은 에러 메시지를 가진 객체입니다.</p>{\" \"}\n        <p>\n          <b className={typographyStyles.note}>\n            {generic.note[currentLanguage]}:\n          </b>{\" \"}\n          V3 과 V4 의 차이점:\n        </p>\n        <ul>\n          <li>\n            <p>V4: 중첩된 객체</p>\n            <p>\n              <strong>사용 이유:</strong> 옵셔널 체이닝이 커뮤니티 사이에서 많이\n              알려졌고, 더 나은 타입 지원을 합니다.\n            </p>\n            <p>\n              <code>{`errors?.yourDetail?.firstName;`}</code>\n            </p>\n          </li>\n          <li>\n            <p>V3: 평탄한 객체</p>\n            <p>\n              <strong>사용 이유:</strong> 단순하고 에러에 접근하기 쉽습니다.\n            </p>\n            <p>\n              <code>{`errors['yourDetail.firstName'];`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    types: (\n      <>\n        여러 종류의 에러가 하나의 필드에 적용되어야 하는 비밀번호 규칙 같은\n        입력의 유효성 검사를 할 때 유용합니다. 이 기능을 활성화하려면,{\" \"}\n        <code>validateCriteriaMode: 'all'</code> 으로 설정해두는 것을 잊지\n        마세요.\n      </>\n    ),\n    message: `메시지는 기본적으로 빈 문자열입니다. 하지만 에러 메시지와 함께 유효성 검사를 함께 등록하면, 이 값이 반환됩니다.`,\n    ref: `입력 엘레먼트에 대한 ref`,\n  },\n  watch: {\n    title: \"watch\",\n    description: (\n      <>\n        <p>\n          지정된 입력을 확인(watch)하고, 그 값들을 반환하며, 렌더링 할 대상을\n          결정할 때 유용합니다.\n        </p>\n        <ul>\n          <li>\n            <p>\n              <code>defaultValue</code>가 정의 안되어 있는 경우,{\" \"}\n              <code>register</code>가 아직 호출이 안되었기 때문에{\" \"}\n              <code>watch</code>의 첫번째 렌더링에서는 <code>undefined</code> 을\n              반환합니다. 하지만, 두번째 인수로 <code>defaultValue</code>를\n              설정하여 값을 반환 할 수 있습니다.\n            </p>\n          </li>\n          <li>\n            <p>\n              <code>useForm</code> 에서 <code>defaultValues</code>로 정의가 되어\n              있다면, 첫번째 렌더링에서 <code>defaultValues</code>에 적용된\n              내용을 반환합니다.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    tableTitle: {\n      single: (\n        <>\n          name으로 입력값 확인 (lodash{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noreferrer noopener\"\n            href=\"https://lodash.com/docs/4.17.15#get\"\n          >\n            get\n          </a>{\" \"}\n          기능과 유사)\n        </>\n      ),\n      multiple: \"여러 입력을 확인\",\n      all: \"모든 입력을 확인\",\n      nest: \"모든 입력을보고 중첩 된 객체를 반환\",\n    },\n  },\n  handleSubmit: {\n    title: \"handleSubmit\",\n    description: (\n      <>\n        <p>\n          이 함수는 유효성 검사가 완료 되었을 때 폼 데이터를\n          전달합니다원격으로도 호출 할 수 있습니다.\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(onSubmit)()\n          </code>\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 비동기 유효성 검사를\n          위한 <code>async</code> 함수를 전달할 수 있습니다 . 예 :{\" \"}\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(async (data) => await fetchAPI(data))\n          </code>\n        </p>\n      </>\n    ),\n  },\n  reset: (goToSection) => ({\n    title: \"reset\",\n    description: (\n      <>\n        <p>\n          이 함수는 폼 내의 필드 값과 에러를 재설정(reset) 합니다.{\" \"}\n          <code> omitResetState </code>를 제공하면 자유롭게 특정 상태 만\n          재설정합니다. <code>values</code>를 옵셔널 인수로 전달하면 폼의 기본\n          값으로 재설정 할 수 있습니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b>{\" \"}\n          <code>React-Select</code> 와 같이 <code>ref</code> 를 노출시키지 않는\n          컴포넌트는,{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"setValue\")}\n          >\n            setValue\n          </button>\n          를 통해 수동으로 입력값을 재설정해주어야 합니다. 또는{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"Controller\")}\n          >\n            Controller\n          </button>\n          을 사용하여 제어 컴포넌트를 감싸 처리할 수 있습니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 당신은해야합니다\n          <code> useForm </code> 또는중 <code> defaultValues ​​</code>제공\n          <code> 컨트롤러 </code>를 재설정하기위한 값으로<code> 재설정 </code>\n          구성 요소의 가치.\n        </p>\n      </>\n    ),\n  }),\n  setError: {\n    title: \"setError\",\n    description: (\n      <>\n        <p>\n          이 함수를 사용하면 한개 혹은 그 이상의 입력값 에러를 수동으로 설정할\n          수 있습니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고</b> :이 방법은 오류와 차단을\n          지속하지 않습니다 제출 조치. <code>handleSubmit</code> 함수 중에 더\n          유용합니다. 비동기 유효성 검사 후 사용자에게 오류 피드백을\n          제공하려고합니다.\n        </p>\n      </>\n    ),\n  },\n  clearError: {\n    title: \"clearError\",\n    description: (\n      <ul>\n        <li>\n          <p>\n            <code>undefined</code>: 모든 에러를 리셋\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string</code>: 하나의 에러 리셋\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string[]</code>: 여러개의 에러 리셋\n          </p>\n        </li>\n      </ul>\n    ),\n  },\n  setValue: {\n    title: \"setValue\",\n    description: (\n      <>\n        <p>\n          이 함수를 통해 동적으로 입력/선택 값을 설정할 수 있습니다. 그와\n          동시에, 아래의 조건이 충족할 때만 다시 랜더링되어 불필요한 리랜더링을\n          피하려 합니다.\n        </p>\n        <ul>\n          <li>\n            <p>값이 업데이트 되면서 에러를 일으킬 때</p>\n          </li>\n          <li>\n            <p>값이 업데이트 되면서 에러를 바로잡을 때</p>\n          </li>\n          <li>\n            <p>\n              맨 처음 실행되어 폼이 <code>dirty</code> 상태가 되도록 했을 때\n            </p>\n          </li>\n          <li>\n            <p>\n              formState 를 <code>touched</code> 로 업데이트 했을 때\n            </p>\n          </li>\n        </ul>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 이 함수를 호출함으로써,{\" \"}\n          <code>formState</code>는 이 입력의 <code>name</code>을{\" \"}\n          <code>touched</code>로 설정하게 됩니다.\n        </p>\n        <p>\n          <code>shouldValidate</code>를 <code>true</code>로 설정하여, 필드\n          유효성 검사를 트리거할 수 도 있습니다. 예 :{\" \"}\n          <code>setValue('name', 'value', true)</code>\n        </p>\n      </>\n    ),\n  },\n  getValues: {\n    title: \"getValues\",\n    description: (\n      <>\n        <p>\n          이 함수는 전체 폼 데이터를 반환하는 함수이며, 폼 내 값을 검색하려는\n          경우에 유용합니다.\n        </p>\n        <ul>\n          <li>\n            <p>\n              기본적으로, <code>getValues()</code>는 폼 데이터를 flat\n              structure로 반환합니다. 예 :{\" \"}\n              <code>{`{ test: 'data', test1: 'data1'}`}</code>\n            </p>\n          </li>\n          <li>\n            <p>\n              정의된 폼 필드에서 <code>getValues({`{ nest: true }`})</code> 는{\" \"}\n              <code>name</code> 입력 값에 따라 중첩된 구조의 데이터로\n              반환됩니다. 예 :{\" \"}\n              <code>{`{ test: [1, 2], test1: { data: '23' } }`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n  },\n  triggerValidation: {\n    title: \"triggerValidation\",\n    description: (\n      <>\n        <p>폼의 입력/선택 유효성 검사를 수동으로 트리거합니다.</p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 유효성 검사에 실패하면{\" \"}\n          <code>errors</code> 객체가 업데이트됩니다.\n        </p>\n      </>\n    ),\n  },\n  validationSchema: {\n    title: \"validationSchema\",\n    description: (\n      <p>\n        외부 스키마와 유효성 검사 규칙을 함께 사용하고 싶을 경우,{\" \"}\n        <code>useForm</code>의 <code>validationSchema</code>를 옵셔널 인자로\n        적용 할 수 있습니다. React Hook Form의 객체 스키마 유효성 검사에서는{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/jquense/yup\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Yup\n        </a>{\" \"}\n        을 지원합니다.\n      </p>\n    ),\n  },\n  Controller: {\n    title: \"Controller\",\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>입력값을 위한 고유의 이름.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td>✓</td>\n          <td>\n            제어 컴포넌트. 예: <code>as=\"input\"</code> 혹은{\" \"}\n            <code>{`as={<TextInput />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>control</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td>✓</td>\n          <td>\n            <code>control</code> 객체는 <code>useForm</code> 을 호출하여 나온\n            것을 넣어주면 됩니다. FormContext 를 사용하고 있다면 필수는\n            아닙니다.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>defaultValue</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>any</code>\n          </td>\n          <td />\n          <td>\n            비제어 컴포넌트의 <code>defaultValue</code> 와 같습니다.{\" \"}\n            <code>boolean</code> 값이 주어졌을 때는, 체크박스 입력값으로\n            다루어집니다.\n            <p>\n              <b className={typographyStyles.note}>참고: </b>{\" \"}\n              <code>defaultValue</code> 또는 <code>useForm</code> 의{\" \"}\n              <code>defaultValues</code> 을 넣어주어야 할 것입니다.\n            </p>\n            <p>\n              <b className={typographyStyles.note}>참고: </b> 만약 폼이 기본값과\n              함께 <code>reset</code>을 호출한다면, 인라인 값으로{\" \"}\n              <code>defaultValues</code> 를 제공하는 대신 useForm 단계에서{\" \"}\n              <code>defaultValues​​</code> 를 제공해주어야 합니다.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>rules</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td />\n          <td>\n            <code>register</code> 에 따른 유효성 검사 규칙.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChange</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (args: any | EventTarget) => any\n            </code>\n          </td>\n          <td />\n          <td>\n            리턴 값을 커스터마이징 할 수 있습니다, 외부 컴포넌트의{\" \"}\n            <code>value</code> prop 이 어떤 형태를 가지고 있는지 알고 있어야\n            합니다. 이벤트 핸들러에 전달된 값이 <code>object</code> 형태이고{\" \"}\n            <code>type</code> 속성값을 포함하고 있는 경우 <code>value</code>{\" \"}\n            혹은 <code>checked</code> 속성값을 읽어올 수 있습니다.\n            <CodeArea\n              withOutCopy\n              rawData={`onChange={{([ event ]) => event.target.value}}\nonChange={{([ { checked } ]) => ({ checked })}}`}\n            />\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChangeName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td />\n          <td>\n            이 prop 은 특정한 이벤트 이름을 지정하여 그 이벤트의 변화를 바라볼\n            수 있도록 합니다. 예: <code>onChange</code> 이벤트가{\" \"}\n            <code>onTextChange</code> 로 되어있는 경우.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onFocus</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>() => void</code>\n          </td>\n          <td></td>\n          <td>\n            <p>\n              유효성 검사 에러가 발생했을 때 이 콜백을 이용하여 특정 인풋으로\n              포커스를 이동시킬 수 있습니다. 이 함수는 포커스만 시킬 수 있다면\n              React 및 React-Native 컴포넌트에 모두 적용됩니다.\n            </p>\n            <p>\n              여기에{\" \"}\n              <a\n                href=\"https://codesandbox.io/s/react-hook-form-controller-auto-focus-5tru5\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                MUI 를 활용한 예제가 있습니다\n              </a>\n              .\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onBlurName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td />\n          <td>\n            이 prop 은 특정한 이벤트 이름을 지정하여 그 이벤트의 변화를 바라볼\n            수 있도록 합니다. 예: <code>onBlur</code> 이벤트가{\" \"}\n            <code>onTextBlur</code> 로 되어있는 경우.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>valueName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td />\n          <td>\n            이 prop 은 <code>value</code> prop 을 다시 정의하여(Override)\n            <code>value</code> prop 을 사용하지 않는 다른 컴포넌트에 사용할 수\n            있습니다. 예: <code>checked</code>, <code>selected</code> 등.\n          </td>\n        </tr>\n      </tbody>\n    ),\n    description: (\n      <>\n        <p>\n          React Hook Form 은 비제어 컴포넌트와 네이티브 입력을 활용하지만{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/JedWatson/react-select\"\n          >\n            React-Select\n          </a>\n          ,{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/ant-design/ant-design\"\n          >\n            AntD\n          </a>{\" \"}\n          혹은{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://material-ui.com/\"\n          >\n            Material-UI\n          </a>{\" \"}\n          와 같은 제어 컴포넌트를 사용하는 외부 라이브러리와 조합하여 사용하는\n          것을 피할 수는 없습니다. 이 래퍼 컴포넌트는 위와 같은 컴포넌트와 쉽게\n          조합하여 사용할 수 있도록 도와주는 역할을 합니다.\n        </p>\n      </>\n    ),\n  },\n  useFormContext: {\n    title: \"useFormContext\",\n    introduction: (\n      <p>\n        폼 컨텍스트(Form Context)는 입력들이 컴포넌트 트리에서 깊이 중첩되었을\n        때 생기는 문제를 해결하고, <code>props</code>를 더 깊이 전달하기 위해\n        사용합니다.\n      </p>\n    ),\n    description: (\n      <>\n        <p>\n          <code>FormContext</code>으로 폼을 감싸면, <code>useFormContext</code>:{\" \"}\n          <code className={typographyStyles.typeText}>function</code> 이 하위\n          컴포넌트에서 호출 될 수 있습니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b>{\" \"}\n          <code>useFormContext</code> 를 통해 모든 <code>useForm</code> 의 hook\n          function이 제공됩니다.\n        </p>\n      </>\n    ),\n  },\n  control: {\n    title: \"control\",\n    description: (\n      <p>\n        이 객체는 React Hook Form 의 Controller 컴포넌트를 위해 만들어졌습니다.\n        안에는 제어되는 컴포넌트를 React Hook Form 에 등록하기 위한 메서드가\n        담겨 있습니다.\n      </p>\n    ),\n  },\n  ErrorMessage: {\n    title: \"ErrorMessage\",\n    description: (\n      <p>입력값의 에러 메세지를 랜더링하기 위한 간단한 컴포넌트입니다.</p>\n    ),\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>연결할 필드 이름.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>errors</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>object</code>\n          </td>\n          <td />\n          <td>\n            <code>errors</code> 객체는 React Hook Form 에서 전달된 것입니다.\n            FormContext 를 쓴다면 필수 값은 아닙니다.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>message</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>인라인 오류 메시지.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td />\n          <td>\n            감싸질 컴포넌트나 HTML 태그. 예: <code>as=\"span\"</code> 나{\" \"}\n            <code>{`as={<Text />}`}</code> 등.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>children</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              ({`{ message: string, messages?: string[]}`}) => any\n            </code>\n          </td>\n          <td />\n          <td>\n            에러 메세지나 일반 메세지를 랜더링하기 위한{\" \"}\n            <a\n              href=\"https://reactjs.org/docs/render-props.html\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              render prop\n            </a>{\" \"}\n            입니다.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> you need to set{\" \"}\n              validateCriteriaMode to 'all' for using <code>messages</code>.\n            </p>\n          </td>\n        </tr>\n      </tbody>\n    ),\n  },\n  NativeValidation: {\n    title: \"Browser built-in validation\",\n    description: (\n      <>\n        <p>\n          다음 예제는 브라우저의 유효성 검사를 활용하는 방법입니다.{\" \"}\n          <code>nativeValidation</code> 을 <code>true</code>로 설정하고, 나머지\n          문법은 표준과 같습니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note</b>: This feature has been\n          removed in V4 due to low usage, but you can still use it in V3\n        </p>\n      </>\n    ),\n  },\n  useFieldArray: {\n    title: \"useFieldArray\",\n    description: (\n      <>\n        <p>\n          비제어 필드 배열 (동적 입력값) 에 대응하기 위한 커스텀 훅입니다. 이\n          훅은 더 나은 사용자 경험과 폼 퍼포먼스를 제공하기 위해서 태어났습니다.{\" \"}\n          <a\n            href=\"https://www.youtube.com/watch?v=Q7lrHuUfgIs\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            이 짧은 비디오를 보고\n          </a>{\" \"}\n          제어 vs 비제어 필드 배열을 비교할 수 있습니다.\n        </p>\n\n        <p>이 훅은 아래의 객체와 함수를 제공합니다.</p>\n\n        <CodeArea rawData={useFieldArrayArgument} />\n\n        <p>\n          <b className={typographyStyles.note}>중요: </b>\n          <code>useFieldArray</code>는 비제어 컴포넌트 기반으로 구성됩니다.\n          아래의 참고 사항은 폼을 구현하면서 비제어 컴포넌트의 특성 상 유념해야\n          하는 점을 새겨둘 수 있도록 돕습니다.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              <code>useForm</code> hook 에 있는 <code>defaultValues</code> 를\n              전달하여 <code>fields</code> 를 생성할 수 있습니다.\n            </p>\n          </li>\n          <li>\n            <p>\n              <code>fields</code> 객체의 <code>id</code> 값을 컴포넌트의 key 로\n              전달하는 것을 잊지 마세요.\n            </p>\n          </li>\n          <li>\n            <p>\n              <code>defaultValue</code>를으로 설정하십시오. 기본값을 설정하려는\n              경우 <code>fields[index]</code>\n              입력을 제거하거나 재설정하십시오.\n            </p>\n          </li>\n          <li>\n            <p>\n              액션을 연속하여 호출할 수 없습니다. 액션은 매 랜더링마다\n              수행되어야 합니다.\n            </p>\n            <CodeArea\n              withOutCopy\n              rawData={`// ❌ The following is not correct\nhandleChange={() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n  append({ test: 'test' });\n}}\n\n// ✅ The following is correct and second action is triggered after next render\nhandleChange={() => {\n  append({ test: 'test' });\n}}\n\nReact.useEffect(() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n}, fields)\n            `}\n            />\n          </li>\n          <li>\n            <p>\n              만약 <code>useFieldArray</code> 를 사용하는 경우, 배열 인풋을\n              등록할 때 <code>{`ref={register}`}</code> 대신{\" \"}\n              <code>{`ref={register()}`}</code> 형태로 사용하는 것이 중요합니다.\n              그래야 <code>register</code> 가 배열의 <code>map</code> 함수\n              안에서 수행됩니다.\n            </p>\n          </li>\n          <li>\n            <code>useEffect</code>의 사용자 정의 레지스터에서는 작동하지\n            않습니다.\n          </li>\n        </ul>\n      </>\n    ),\n    table: (\n      <>\n        <tr>\n          <td>\n            <code>fields</code>\n          </td>\n          <td width={320}>\n            <code className={typographyStyles.typeText}>\n              object & {`{ id: string }`}\n            </code>\n          </td>\n          <td>\n            이 객체는 input 을 생성하고 랜더링하기 위한 주요 객체(source of\n            truth)입니다.\n            <p>\n              <b className={typographyStyles.note}>중요: </b> 모든 입력 필드는\n              비제어 상태이기 떄문에, <code>map</code> 으로 생성되는 컴포넌트에\n              <code>id</code> 값을 필수로 전달해주어야 합니다. 그래야 리액트가\n              어떤 아이템이 추가되고, 변경되고, 제거되는지 파악할 수 있습니다.\n            </p>\n            <p>\n              예: <code>{`{fields.map(d => <input key={d.id} />)}`}</code>\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>append</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (obj: object | object[]) => void\n            </code>\n          </td>\n          <td>입력 필드(들)를 현재 필드들 마지막에 추가합니다.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>prepend</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (obj: object | object[]) => void\n            </code>\n          </td>\n          <td>입력 필드(들)를 현재 필드들 맨 앞에 추가합니다.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>insert</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (index: number, value: object) => void\n            </code>\n          </td>\n          <td>입력 필드(들)를 특정 위치에 추가합니다.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>swap</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (from: number, to: number) => void\n            </code>\n          </td>\n          <td>입력 필드(들)의 위치를 서로 교체합니다.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>move</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (from: number, to: number) => void\n            </code>\n          </td>\n          <td>\n            입력 필드(들)를 다른 위치로 이동합니다.\n            <p>\n              <b className={typographyStyles.note}>참고:</b> <code>move</code>{\" \"}\n              와 <code>swap</code> 의 차이점을 설명하자면, <code>move</code> 를\n              계속 호출하는 것은 입력 필드(들)를 임의의 공간 안에 집어넣는 것과\n              비슷하고, <code>swap</code> 은 두 입력 필드들의 위치만 바꾸는\n              것입니다.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>remove</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (index?: number | number[]) => void\n            </code>\n          </td>\n          <td>\n            특정 위치에 있는 입력 필드(들)를 제거합니다. 인덱스를 넣지 않았다면\n            전체를 제거합니다.\n          </td>\n        </tr>\n      </>\n    ),\n  },\n  validationResolver: {\n    title: \"validationResolver\",\n    description: (\n      <>\n        <p>\n          이 함수는\n          <a\n            href=\"https://github.com/hapijs/joi\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Joi\n          </a>\n          ,{\" \"}\n          <a\n            href=\"https://github.com/ianstormtaylor/superstruct\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Superstruct\n          </a>{\" \"}\n          등의 외부 유효성 검사 방법들을 실행할 수 있도록 합니다. 실제로, 이\n          함수의 목적은 단순히 외부 유효성 검사 라이브러리로 Yup 등을 제한된\n          범위로 지원하는 정도에서 끝나지 않습니다. 우리는 다양한 라이브러리가\n          React Hook Form 과 함께 동작할 수 있도록 지원하려 합니다. 심지어\n          유효성 검사를 위해 직접 커스터마이징할 수도 있습니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 반드시{\" \"}\n          <code>values</code> 와 <code>errors</code> 객체를 모두 포함하여\n          리턴시키세요, 그리고 이 객체들의 기본값은 빈 객체 <code>{`{}`}</code>{\" \"}\n          가 되어야 합니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> errors 객체의 키 값은\n          반드시 인풋 값과 연결되어야 합니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 이 함수는\n          <code>validationSchema</code>와 유사한 사용자 정의 후크 내부에\n          캐시되며, <code>validationContext</code>는 다시 렌더링 할 때마다\n          변경할 수있는 변경 가능한 객체입니다.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>참고:</b> 입력값을 다시 검사하는\n          것은 사용자의 행동에 따라 한 필드당 하나씩만 동작합니다. 왜냐하면\n          라이브러리 자체에서 에러 객체의 특정 필드를 대조해보고 그에 따라\n          리랜더링을 실행하기 때문입니다.\n        </p>\n      </>\n    ),\n  },\n}\n","import * as React from \"react\"\nimport Layout from \"../../components/layout\"\nimport Seo from \"../../components/seo\"\nimport ApiPage from \"../../components/ApiPage\"\nimport api from \"../../data/kr/api-v5\"\n\nconst Api = ({\n  location,\n}: {\n  location: {\n    search: string\n    pathname: string\n  }\n}) => (\n  <Layout location={location} defaultLang=\"kr\">\n    <Seo title={api.title} location={location} />\n    <ApiPage defaultLang=\"kr\" />\n  </Layout>\n)\n\nexport default Api\n"],"sourceRoot":""}