{"version":3,"sources":["webpack:///./src/data/pt/api-v5.tsx","webpack:///./src/pages/v5/api.pt.tsx"],"names":["Popup","typographyStyles","note","colors","lightPink","buttonStyles","links","codeBlock","typeText","CodeArea","useFieldArrayArgument","ApiPT","location","defaultLang","title","api","ApiPage"],"mappings":"6PAUe,EACN,mBAQH,WA6BA,WAgBA,WAYA,WAOA,WAKA,WAyEaA,EAAA,EAWb,WAOkBC,IAAiBC,KAgCnC,WAQkBD,IAAiBC,KAUnC,WAUkBD,IAAiBC,KAWNC,IAAOC,UAMrBC,IAAaC,MA+D1B,WAkBF,WAIkBL,IAAiBC,KAwBnC,WA+CA,WAaA,WA4BE,WAoBF,WAMqBD,IAAiBM,UAKpBN,IAAiBC,KAIdD,IAAiBM,UAkDtC,WAIkBN,IAAiBC,KAiCnC,WA4BkBD,IAAiBC,KAenC,WA6BA,WAKkBD,IAAiBC,KAepBG,IAAaC,MAoBLL,IAAiBO,SAUjBP,IAAiBO,SAejBP,IAAiBO,SAajBP,IAAiBO,SAQlBP,IAAiBC,KAKjBD,IAAiBC,KAYhBD,IAAiBO,SAYjBP,IAAiBO,SASjCC,EAAA,EAYgBR,IAAiBO,SAajBP,IAAiBO,SA2BjBP,IAAiBO,SAajBP,IAAiBO,SAaxC,WAqDA,WAIqBP,IAAiBO,SAIpBP,IAAiBC,KAgCZD,IAAiBO,SAUjBP,IAAiBO,SAajBP,IAAiBO,SAUjBP,IAAiBO,SAejBP,IAAiBO,SAgBlBP,IAAiBC,KAWvC,WAQkBD,IAAiBC,KASnC,WAgBGO,EAAA,EAAkBC,IAGHT,IAAiBC,KAgC5BO,EAAA,EAwCP,WAMuBR,IAAiBO,SAQlBP,IAAiBC,KAehBD,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAWjBP,IAAiBO,SAOlBP,IAAiBC,KAYhBD,IAAiBO,SAexC,WAyBkBP,IAAiBC,KAMjBD,IAAiBC,KAIjBD,IAAiBC,KAOjBD,IAAiBC,KCtuC1BS,UAdD,SAAC,GAAD,IACZC,EADY,EACZA,SADY,OAQZ,gBAAC,IAAD,CAAQA,SAAUA,EAAUC,YAAa,MACvC,gBAAC,IAAD,CAAKC,MAAOC,EAAWH,SAAUA,IACjC,gBAACI,EAAA,EAAD,CAASH,YAAY","file":"component---src-pages-v-5-api-pt-tsx-4e1a897dc6474c6f29d3.js","sourcesContent":["import * as React from \"react\"\nimport colors from \"../../styles/colors\"\nimport Popup from \"../../components/Popup\"\nimport generic from \"../generic\"\nimport CodeArea from \"../../components/CodeArea\"\nimport useFieldArrayArgument from \"../../components/codeExamples/useFieldArrayArgument\"\nimport typographyStyles from \"../../styles/typography.module.css\"\nimport buttonStyles from \"../../styles/button.module.css\"\nimport code from \"../../components/codeExamples/defaultExample\"\n\nexport default {\n  title: \"API Documentação\",\n  header: {\n    description:\n      \"foca em prover a melhor experiência para o desenvolvedor com uma API Simplificada\",\n  },\n  useForm: {\n    title: \"useForm\",\n    intro: (\n      <>\n        Utilizando <code>useForm</code>, você receberá os seguintes métodos{\" \"}\n      </>\n    ),\n    description: (\n      <p>\n        <code>useForm</code> também tem argumentos <b>opcionais</b>. O exemplo a\n        seguir demonstra todas as opções, com valor padrão.\n      </p>\n    ),\n    validationResolver: (goToSection) => (\n      <>\n        <p>\n          Essa função de callback permite que você execute sua validação através\n          de qualquer esquema ou validação customizada. A função recebe um\n          formulário completo com os <code>value</code> como argumento. Você\n          deve validar o resultado e retornar ambos <code>value</code> e{\" \"}\n          <code>errors</code>. Leia mais em{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"validationResolver\")}\n          >\n            validationResolver\n          </button>{\" \"}\n          section.\n        </p>\n      </>\n    ),\n    validateContext: (\n      <>\n        <p>\n          Esse objeto de contexto será injetado no segundo argumento de{\" \"}\n          <code>validationResolver</code> ou em{\" \"}\n          <a\n            href=\"https://github.com/jquense/yup\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Yup\n          </a>{\" \"}\n          validation's context object.\n        </p>\n      </>\n    ),\n    validateCriteriaMode: (\n      <>\n        <p>\n          O comportamento padrão <code>firstError</code> irá validar todos os\n          campos e reunir todos os primeiros erros encontrados.\n        </p>\n        <p>\n          Com a configuração de <code>all</code>, todos as validações de campos\n          irão executar e reunir todos os erros encontrados\n        </p>\n      </>\n    ),\n    validateOnSubmit: (\n      <>\n        A validação irá ativar o evento de <code>submit</code> e os campos\n        inválidos serão anexados, o evento <code>onChange</code> ouve os eventos\n        para valida-los novamente.\n      </>\n    ),\n    validateOnBlur: (\n      <>\n        <code>Validation</code> irá ativar o evento de <code>blur</code>.\n      </>\n    ),\n    validateOnChange: (\n      <>\n        A validação irá ativar o evento de <code>change</code> com cada campo,\n        levará a multiplas re-renderizações. Não recomendado: Considere isto\n        como uma prática não performática.\n      </>\n    ),\n    defaultValues: (goToSection) => (\n      <>\n        <p>\n          Você pode setar o valor padrão do campoo com{\" \"}\n          <code>defaultValue/defaultChecked</code>{\" \"}\n          <a\n            className={buttonStyles.links}\n            href=\"https://reactjs.org/docs/uncontrolled-components.html\"\n          >\n            (leia mais na documentação do React, para valores padrões)\n          </a>{\" \"}\n          ou passe <code>defaultValues</code> como argumento opcional, para\n          popular valores padrões para todo o formulário.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Importante:</b>{\" \"}\n          <code>defaultValues</code> is cached within the custom hook, if you\n          want to reset <code>defaultValues</code> please use{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"reset\")}\n          >\n            reset\n          </button>{\" \"}\n          api.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Valores definidos em{\" \"}\n          <code>defaultValues</code> será injetado em{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"watch\")}\n          >\n            verificar\n          </button>{\" \"}\n          como <code>defaultValue</code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b>{\" \"}\n          <code>defaultValues</code> não é populado automaticamente, com o\n          registro manual do campo (ex:{\" \"}\n          <code>{`register({ name: 'test' })`}</code>) porquê o campo manual{\" \"}\n          <code>register</code> não provê <code>props ref</code> para o React\n          Hook Form.\n        </p>\n      </>\n    ),\n    validationSchema: (goToSection) => (\n      <p>\n        Aplique regras de validação do formulário com <code>Yup</code> a nível\n        de esquema, por favor, verifique a seção{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"validationSchema\")}\n        >\n          validationSchema\n        </button>{\" \"}\n        .\n      </p>\n    ),\n    reValidateMode: (\n      <p>\n        Esta opção permite configurar quando entradas com erros são exibidas e\n        revalidadas (por padrão, a validação é acionada durante uma entrada\n        mudança.) <Popup />\n      </p>\n    ),\n    validationFields: (\n      <p>\n        Fornecer uma matriz de campos (array) significa que apenas os campos\n        incluídos serão validados. Esta opção é útil quando você deseja alternar\n        quais campos são necessários para validar.\n      </p>\n    ),\n    submitFocusError: (\n      <>\n        <p>\n          Por padrão, quando o usuário envia um formulário e contém um erro, o\n          primeiro campo com erro será focado.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Apenas campos\n          registrados com <code>ref</code> irá funcionar. Manualmente\n          registrando os inputs não funcionará. ex:{\" \"}\n          <code>{`register({ name: 'test' }) // doesn't work`}</code>{\" \"}\n        </p>\n      </>\n    ),\n    nativeValidation: (goToSection) => (\n      <p>\n        Setar esta opção para <code>true</code> irá habilitar a validação nativa\n        do navegador. Você pode{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation\"\n        >\n          veja mais sobre as validações imbutidas no navegador\n        </a>\n        , e veja também a seção{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"nativeValidation\")}\n        >\n          nativeValidation\n        </button>{\" \"}\n        para mais detalhes e exemplos.\n      </p>\n    ),\n  },\n  unregister: {\n    title: \"unregister\",\n    description: (\n      <>\n        <p>\n          Este método permite você <code>unregister</code> um único campo ou\n          matriz (array) de campos. Isto é útil quando você precisa registrar\n          seu campo durante o <code>useEffect</code> como registro customizado e\n          para remover o registro após o componente ser desmontado.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Quando você remove o\n          registro do campo, seu valor não será mais incluído no dado do\n          formulário quando for submetido.\n        </p>\n      </>\n    ),\n  },\n  register: {\n    title: \"register\",\n    description: (\n      <>\n        <p>\n          Este método permite você o uso do register para input/select{\" \"}\n          <code>Ref</code> e validar regras do React Hook Form.\n        </p>\n        <p>\n          Regras de validação são baseadas no padrão do HTML e também permite\n          customizações.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Importante:</b> <code>name</code>{\" \"}\n          é <b>obrigatório</b> e <b>unique</b>. O name do campo também suporta\n          pontos e chaves como sintaxe, o que possibilita você criar campos\n          aninhados. A tabela de exemplo está abaixo:\n        </p>\n      </>\n    ),\n    fieldArray: (\n      <p\n        style={{\n          paddingLeft: 10,\n          borderLeft: `4px solid ${colors.lightPink}`,\n        }}\n      >\n        Se estiver trabalhando com <code>arrays/array fields</code>, você pode\n        assinar um campo name com <code>name[index]</code>.{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/react-hook-form/react-hook-form/blob/master/examples/FieldArray.tsx\"\n          title=\"example for Field Array\"\n        >\n          Confira o exemplo com campo Matriz(Array)\n        </a>\n        .\n      </p>\n    ),\n    example: \"Enviar\",\n    selectHelp:\n      \"Ao selecionar a opção de registro, a tabela da API abaixo será atualizada.\",\n    options: {\n      title: \"Opções do 'Register'\",\n      registerWithValidation: \"'Register' com validação\",\n      registerWithValidationMessage:\n        \"'Register' com validação e mensagem de erro\",\n      note: (goToSection) => (\n        <>\n          <h2 className={typographyStyles.title}>Register Customizado</h2>\n          <p>\n            Você também pode registrar entradas manualmente, o que é útil quando\n            trabalhando com componentes personalizados e <code>Ref</code> não é\n            acessível. Este é realmente o caso quando você está trabalhando com\n            React Native ou personalizado como{\" \"}\n            <a\n              href=\"https://github.com/JedWatson/react-select\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              react-select\n            </a>\n            .\n          </p>\n\n          <p>\n            Usando uma chamada de registro personalizada, você precisará\n            atualizar a entrada valor com{\" \"}\n            <button\n              className={buttonStyles.codeAsLink}\n              onClick={() => goToSection(\"setValue\")}\n            >\n              setValue\n            </button>\n            , porque o campo não está mais registrado como o ref.\n          </p>\n\n          <p>\n            <code\n              className={typographyStyles.codeBlock}\n            >{`register({ name: 'firstName' }, { required: true, min: 8 })`}</code>\n          </p>\n\n          <p>\n            <b className={typographyStyles.note}>Nota:</b> Se você fizer um\n            registro de campo customizado para ativar a re-renderização seu\n            valor, então você precisa dar um tempo ao seu campo{\" \"}\n          </p>\n        </>\n      ),\n    },\n    validation: {\n      required: (\n        <>\n          Um booleano que, se verdadeiro, indica que a entrada deve ter um valor\n          antes que o formulário possa ser enviado. Você pode atribuir uma\n          string para retornar uma mensagem de erro no objeto de{\" \"}\n          <code>errors</code>.\n        </>\n      ),\n      maxLength: \"O tamanho máximo do valor a ser aceito para este campo.\",\n      minLength: \"O tamanho mínimo do valor a ser aceito para este campo.\",\n      max: \"O valor máximo a ser aceito pelo campo.\",\n      min: \"O valor mínimo a ser aceito pelo campo.\",\n      pattern: \"Um padrão regex para o campo.\",\n      validate: `Você pode passar uma função de callback como argumento para validar, ou você pode passar um objeto de função callback para validar todos eles. (verifique os exemplos)`,\n    },\n  },\n  formState: {\n    title: \"formState\",\n    description: (\n      <>\n        <p>Este objeto contém informação sobre o estado do formulário.</p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>formState</code> é encapsulado com{\" \"}\n          <a\n            href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Proxy\n          </a>{\" \"}\n          para melhorar a performance do <code>render</code>. Tenha certeza que\n          você tem <code>invoke/read</code>\n          antes do <code>render</code> para habilitar a atualização do estado.\n          este O recurso de funcionalidade de redução de renderização se aplica\n          somente à plataforma da Web devido a uma falta de suporte no{\" \"}\n          <code>Proxy</code> no React Native.\n        </p>\n      </>\n    ),\n    dirty: \"Marcado como true após o usuário interagir com algum dos campos.\",\n    dirtyFields: \"Um conjunto exclusivo de campos modificados pelo usuário.\",\n    isSubmitted:\n      \"Marcado como true após o usuário submeter o formulário. Após o envio de um formulário, seu estado permanecerá enviado até ser chamado com o método de redefinição.\",\n    touched: \"Uma matriz (Object) com todos os campos que foram interagidos.\",\n    isSubmitting: (\n      <>\n        Durante a submissão do formulário irá setar <code>true</code> e depois\n        submeter para <code>false</code>\n      </>\n    ),\n    submitCount: \"Número de formulários submetidos.\",\n    isValid: \"Marcado como verdadeiro se não tiver erro.\",\n  },\n  errors: {\n    title: \"errors\",\n    description: (currentLanguage) => (\n      <>\n        <p>\n          Objeto contendo erros de formulário, ou mensagens de erro que\n          pertencem a cada campo.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>\n            {generic.note[currentLanguage]}:\n          </b>{\" \"}\n          Diferença entre a versão 3 e 4:\n        </p>\n\n        <ul>\n          <li>\n            <p>Versão 4: Objetos aninhados</p>\n            <p>\n              <strong>Razão:</strong> com o encadeamento opcional se tornando\n              mais popular entre a comunidade e para dar melhor suporte a tipo.\n            </p>\n            <p>\n              <code>{`errors?.yourDetail?.firstName;`}</code>\n            </p>\n          </li>\n          <li>\n            <p>Versão 3: Objetos nivelados</p>\n            <p>\n              <strong>Razão:</strong> simples e fácil de acessar o erro.\n            </p>\n            <p>\n              <code>{`errors['yourDetail.firstName'];`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    types: (\n      <>\n        Isto é útil para validação de campos como regras de senha, com múltiplos\n        errors que precisam ser retornados de um único campo. Para habilitar\n        essa funcionalidade, tenha certeza de setar{\" \"}\n        <code>validateCriteriaMode: 'all'</code>.\n      </>\n    ),\n    message: `'Message' é um campo string e vazio por padrão. Entretanto, se você registrar a validação com mensagem de erro, ele será retornado.`,\n    ref: `Referência para o elemento do campo.`,\n  },\n  watch: {\n    title: \"watch\",\n    description: (\n      <>\n        <p>\n          Isso irá assistir campo(s) específicos e retornará um valor, é útil\n          para determinar o que será redenrizado.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              Quando <code>defaultValue</code> não está definido, o primeiro a\n              renderizar do <code>watch</code> retornará <code>undefined</code>{\" \"}\n              porque é chamado antes do <code>register</code>, porém você pode\n              utilizar <code>defaultValue</code> como segundo argumento a ser\n              retornado.\n            </p>\n          </li>\n          <li>\n            <p>\n              Entretanto, se <code>defaultValues</code> foi inicializado em{\" \"}\n              <code>useForm</code> como argumento, então o primeiro render irá\n              retornar o que é provido em <code>defaultValues</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    tableTitle: {\n      single: (\n        <>\n          Assista o valor do campo pelo 'name' (similar ao lodash{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noreferrer noopener\"\n            href=\"https://lodash.com/docs/4.17.15#get\"\n          >\n            get\n          </a>{\" \"}\n          function)\n        </>\n      ),\n      multiple: \"Assista múltiplos campos\",\n      all: \"Assista todos os campos\",\n      nest: \"Assista a todas as entradas e retorne objeto aninhado\",\n    },\n  },\n  handleSubmit: {\n    title: \"handleSubmit\",\n    description: (\n      <>\n        <p>\n          Esta função irá passar os dados do formulário quando a validação do\n          formulário for um sucesso e também pode ser chamado remotamente.\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(onSubmit)()\n          </code>\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Você pode passar uma\n          função <code>async</code> para validação assíncrona. ex:{\" \"}\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(async (data) => await fetchAPI(data))\n          </code>\n        </p>\n      </>\n    ),\n  },\n  reset: (goToSection) => ({\n    title: \"reset\",\n    description: (\n      <>\n        <p>\n          Essa função irá limpar o valor dos campos, e erros dentro do\n          formulário. Ao fornecer <code> omitResetState </code>, você tem a\n          liberdade de redefina apenas parte específica do estado. Você pode\n          passar <code>values</code> como valor opcional para resetar o\n          formulário assinado com o valor padrão.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Para componentes\n          controlados como <code>React-Select</code> que não expõe{\" \"}\n          <code>ref</code>, você irá precisar resetar o campo manualmente\n          através{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"setValue\")}\n          >\n            setValue\n          </button>{\" \"}\n          ou usando{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"Controller\")}\n          >\n            Controller\n          </button>{\" \"}\n          para encapsular seu componente controlado.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Você vai precisar\n          fornecer <code> defaultValues ​​</code> durante <code> useForm </code>\n          ou<code> reset </code> com valor para redefinir no\n          <code> Controller </code>o valor dos componentes.\n        </p>\n      </>\n    ),\n  }),\n  setError: {\n    title: \"setError\",\n    description: (\n      <>\n        <p>A função permite você manualmente setar um ou múltiplos erros.</p>\n\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> este método não\n          persistirá o erro e bloqueará a ação de envio. É mais útil durante a\n          função <code>handleSubmit</code> quando você deseja fornecer feedback\n          de erro aos usuários após a validação assíncrona.\n        </p>\n      </>\n    ),\n  },\n  clearError: {\n    title: \"clearError\",\n    description: (\n      <ul>\n        <li>\n          <p>\n            <code>undefined</code>: limpa todos os erros\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string</code>: reseta um único erro\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string[]</code>: reseta múltiplos erros\n          </p>\n        </li>\n      </ul>\n    ),\n  },\n  setValue: {\n    title: \"setValue\",\n    description: (\n      <>\n        <p>\n          Esta função permite definir dinamicamente o campo / seleção do valor.\n          Ao mesmo tempo, tenta evitar a nova renderização quando não é\n          necessário e apenas as seguintes condições acionarão a nova\n          renderização.\n        </p>\n        <ul>\n          <li>\n            <p>Quando um erro é acionado pela atualização de um valor</p>\n          </li>\n          <li>\n            <p>Quando um erro é corrigido por uma atualização de valor</p>\n          </li>\n          <li>\n            <p>\n              quando 'setValue' é invocado pela primeira vez e formState{\" \"}\n              <code>dirty</code> é marcado como verdadeiro (true)\n            </p>\n          </li>\n          <li>\n            <p>\n              Quando setValue é invocado e formState <code>touched</code> é\n              atualizado\n            </p>\n          </li>\n        </ul>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Ao chamar este método,{\" \"}\n          <code>formState</code> vai adicionar aos campos o <code>name</code> em{\" \"}\n          <code>touched</code>.\n        </p>\n        <p>\n          Você pode também setar <code>shouldValidate</code> para{\" \"}\n          <code>true</code> e vai acionar a validação do campo. ex:{\" \"}\n          <code>setValue('name', 'value', true)</code>\n        </p>\n      </>\n    ),\n  },\n  getValues: {\n    title: \"getValues\",\n    description: (\n      <>\n        <p>\n          Essa função vai retornar todo o dado do formulário, e é útil em uma\n          função quando você precisa capturar os dados do formulário.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              Por padrão <code>getValues()</code> irá retornar todo o dado do\n              formulário em uma estrutura plana. ex:{\" \"}\n              <code>{`{ test: 'data', test1: 'data1'}`}</code>\n            </p>\n          </li>\n          <li>\n            <p>\n              Trabalhando com campos definidos do formulário,{\" \"}\n              <code>getValues({`{ nest: true }`})</code> irá retornar o dado em\n              uma estrutura aninhada de acordo com o campo <code>name</code>.\n              ex: <code>{`{ test: [1, 2], test1: { data: '23' } }`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n  },\n  triggerValidation: {\n    title: \"triggerValidation\",\n    description: (\n      <>\n        <p>\n          Para acionamento manual do campo / select de validação de formulário.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Quando a validação\n          falha, o <code>errors</code> objeto será atualizado.\n        </p>\n      </>\n    ),\n  },\n  validationSchema: {\n    title: \"validationSchema\",\n    description: (\n      <p>\n        Se você preferir, pode centralizar a validação de regras com validação\n        externa, validação de esquema, você pode aplicar{\" \"}\n        <code>validationSchema</code> em <code>useForm</code> como argumento\n        opcional. React Hook Form atualmente suporta{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/jquense/yup\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Yup\n        </a>{\" \"}\n        para validação de esquema de objeto.\n      </p>\n    ),\n  },\n  Controller: {\n    title: \"Controller\",\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>\"Name\" único do seu campo.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td>✓</td>\n          <td>\n            Componente controlado. ex: <code>as=\"input\"</code> ou{\" \"}\n            <code>{`as={<TextInput />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>control</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td>✓</td>\n          <td>\n            <code>control</code> objeto é invocado do <code>useForm</code>. é\n            opcional, se estiver usando o FormContext.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>defaultValue</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>any</code>\n          </td>\n          <td></td>\n          <td>\n            O mesmo que componente não controlado <code>defaultValue</code>,\n            quando suprido um valor <code>boolean</code>, ele será tratado como\n            checkbox.\n            <p>\n              <b className={typographyStyles.note}>Nota:</b> você precisa\n              fornecer <code>defaultValue</code> ou <code>defaultValues</code>{\" \"}\n              em <code>useForm</code>\n            </p>\n            <p>\n              <b className={typographyStyles.note}>Note</b>: se o seu formulário\n              invocar <code> reset </code> com valores diferentes, você\n              precisará fornecer <code>defaultValues</code> no nível useForm em\n              vez de definido inline <code>defaultValue</code>..\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>rules</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td></td>\n          <td>\n            Regras de validação de acordo com o <code>register</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChange</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (args: any | EventTarget) => any\n            </code>\n          </td>\n          <td></td>\n          <td>\n            A propriedade <code>onChange</code> lhe permite customizar o retorno\n            do valor, verifique se o formato do componente externo{\" \"}\n            <code>value</code> props.\n            <CodeArea\n              withOutCopy\n              rawData={`onChange={{([ event ]) => event.target.value}}\nonChange={{([ event, data ]) => ({ checked: data.checked})}}`}\n            />\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChangeName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            Este propridade lhe permite marcar eventos específicos, ex: quando{\" \"}\n            <code>onChange</code> evento é chamado <code>onTextChange</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onFocus</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>() => void</code>\n          </td>\n          <td></td>\n          <td>\n            <p>\n              Esse retorno de chamada permite que o gancho personalizado se\n              concentre na entrada quando há um erro. Esta função é aplicável\n              para ambos, React e Componentes do React-Native desde que possam\n              ser focados.\n            </p>\n            <p>\n              <a\n                href=\"https://codesandbox.io/s/react-hook-form-controller-auto-focus-5tru5\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                Aqui está um exemplo de trabalho.\n              </a>\n              .\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onBlurName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            Esta propridade lhe permite marcar eventos específicos, ex: quando o{\" \"}\n            <code>onBlur</code> evento é chamado <code>onTextBlur</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>valueName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            Esta propriedade lhe permite sobrescrever a propriedade{\" \"}\n            <code>value</code> e suporta outros componentes que não utilizam a\n            propriedade <code>value</code>. ex: <code>checked</code>,{\" \"}\n            <code>selected</code> e outros...\n          </td>\n        </tr>\n      </tbody>\n    ),\n    description: (\n      <>\n        <p>\n          O React Hook Form adota componentes não controlados e campos nativos,\n          no entanto, é difícil evitar trabalhar com componentes externos\n          controlados, tais como{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/JedWatson/react-select\"\n          >\n            React-Select\n          </a>\n          ,{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/ant-design/ant-design\"\n          >\n            AntD\n          </a>{\" \"}\n          e{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://material-ui.com/\"\n          >\n            Material-UI\n          </a>\n          . Este componente irá fazer sua vida mais simples.\n        </p>\n        <p>\n          Cada <code>props</code> que se passa para um componente conntrolado,\n          será encaminhado para a instância do componente que você proveu com a\n          propriedade <code>as</code>. Isto significa que você possui um\n          componente custom <code>Switch</code> que necessita de uma propriedade{\" \"}\n          <code>label</code>. Você pode passar essa propriedade diretamente para\n          o componente controlado. A propriedade <code>name</code> será usada\n          principalmente para acessar o valor através do formulário depois.\n        </p>\n      </>\n    ),\n  },\n  useFormContext: {\n    title: \"useFormContext\",\n    introduction: (\n      <p>\n        O contexto do formulário visa solucionar o problema quando houver\n        profundos campos aninhados em sua árvore de componentes e métodos de\n        passagem no fundo como\n        <code>props</code> se torna trabalhoso.\n      </p>\n    ),\n    description: (\n      <>\n        <p>\n          Uma vez que seu formulário utiliza <code>FormContext</code>, o{\" \"}\n          <code>useFormContext</code>:{\" \"}\n          <code className={typographyStyles.typeText}>function</code> pode ser\n          chamado como componente filho.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> chamar{\" \"}\n          <code>useFormContext</code> o <code>useForm</code> irá te dar todas as\n          funções dos hooks.\n        </p>\n      </>\n    ),\n  },\n  control: {\n    title: \"control\",\n    description: (\n      <p>\n        Esse objeto foi criado para o componente Controlador do formulário React\n        Hook, que contém métodos para registrar o componente controlado no React\n        Hook Formato.\n      </p>\n    ),\n  },\n  ErrorMessage: {\n    title: \"ErrorMessage\",\n    description: (\n      <p>\n        Um simples componente para renderizar a mensagem de erro do campo\n        associado.\n      </p>\n    ),\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>campo name associado.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>errors</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>object</code>\n          </td>\n          <td></td>\n          <td>\n            <code>errors</code> objeto do React Hook Form. é opcional se estiver\n            usando FormContext.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>message</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>mensagem de erro em linha.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td></td>\n          <td>\n            Um componente ou tag HTML. ex: <code>as=\"span\"</code> or{\" \"}\n            <code>{`as={<Text />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>children</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              ({`{ message: string, messages?: string[]}`}) => any\n            </code>\n          </td>\n          <td></td>\n          <td>\n            Este é um{\" \"}\n            <a\n              href=\"https://reactjs.org/docs/render-props.html\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              render prop\n            </a>{\" \"}\n            para renderizar mensagem de erro ou mensagens.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> you need to set{\" \"}\n              validateCriteriaMode to 'all' for using <code>messages</code>.\n            </p>\n          </td>\n        </tr>\n      </tbody>\n    ),\n  },\n  NativeValidation: {\n    title: \"Validações nativas do browser\",\n    description: (\n      <>\n        <p>\n          O exemplo a seguir demonstra como você pode aproveitar a validação do\n          navegador. Você apenas precisa setar <code>nativeValidation</code>{\" \"}\n          para <code>true</code> e o restante da sintaxe é igual à validação\n          padrão.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note</b>: This feature has been\n          removed in V4 due to low usage, but you can still use it in V3\n        </p>\n      </>\n    ),\n  },\n  useFieldArray: {\n    title: \"useFieldArray\",\n    description: (\n      <>\n        <p>\n          Um custom hook para usar com Arrays de campos não-controlados (inputs\n          dinâmicos). A motivação por trás disso é fornecer melhor experiência\n          ao usuário e performance ao formulário. Você pode assistir{\" \"}\n          <a\n            href=\"https://www.youtube.com/watch?v=Q7lrHuUfgIs\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            este video\n          </a>{\" \"}\n          para comparar arrays controlados e não controlados.\n        </p>\n        <p>Esse hook fornece os seguintes objetos e funções:</p>\n\n        <CodeArea rawData={useFieldArrayArgument} />\n\n        <p>\n          <b className={typographyStyles.note}>Importante: </b> O\n          <code>useFieldArray</code> é construído sobre componentes não\n          controlados. As notas a seguir ajudarão você a estar ciente e\n          consciente de suas comportamento durante a implementação.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              Você pode popular os <code>fields</code> fornecendo\n              <code>defaultValues</code> no <code>useForm</code> hook.\n            </p>\n          </li>\n          <li>\n            <p>\n              certifique-se de atribuir <code>id</code> a partir de{\" \"}\n              <code>fields</code>\n              objeto como sua chave de componente.\n            </p>\n          </li>\n          <li>\n            <p>\n              certifique-se de definir <code>defaultValue</code> como\n              <code>field[index]</code> quando você deseja definir o valor\n              padrão, remova ou redefina com entradas.\n            </p>\n          </li>\n          <li>\n            <p>\n              você não pode chamar ações uma após a outra. As ações precisam ser\n              acionado por renderização.\n            </p>\n            <CodeArea\n              withOutCopy\n              rawData={`// ❌ The following is not correct\nhandleChange={() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n  append({ test: 'test' });\n}}\n\n// ✅ The following is correct and second action is triggered after next render\nhandleChange={() => {\n  append({ test: 'test' });\n}}\n\nReact.useEffect(() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n}, fields)\n            `}\n            />\n          </li>\n          <li>\n            <p>\n              é <strong>importante</strong> aplicar{\" \"}\n              <code>{`ref={register()}`}</code> ao invés de{\" \"}\n              <code>{`ref={register}`}</code> quando estiver trabalhando com{\" \"}\n              <code>useFieldArray</code> para que o <code>register</code> seja\n              invocado durante <code>map</code>.\n            </p>\n          </li>\n          <li>\n            Ele não funciona com o registro personalizado em{\" \"}\n            <code>useEffect</code>.\n          </li>\n        </ul>\n      </>\n    ),\n    table: (\n      <>\n        <tr>\n          <td>\n            <code>fields</code>\n          </td>\n          <td width={320}>\n            <code className={typographyStyles.typeText}>\n              object & {`{ id: string }`}\n            </code>\n          </td>\n          <td>\n            Esse objeto é onde o <code>map</code> confia para renderizar os\n            campos.\n            <p>\n              <b className={typographyStyles.note}>Importante: </b>\n              Porque cada campo pode ser não-controlado, <code>id</code> é\n              mandatório com componentes mapeados, para ajudar o React a\n              identificar quais itens mudaram, foram adicionados ou removidos.\n            </p>\n            <p>\n              ex: <code>{`{fields.map(d => <input key={d.id} />)}`}</code>\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>append</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (obj: object | object[]) => void\n            </code>\n          </td>\n          <td>Append input/inputs no final de seus campos.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>prepend</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (obj: object | object[]) => void\n            </code>\n          </td>\n          <td>Prepend input/inputs no começo de seus campos.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>insert</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (index: number, value: object) => void\n            </code>\n          </td>\n          <td>Insert input/inputs em uma posição particular.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>swap</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (from: number, to: number) => void\n            </code>\n          </td>\n          <td>Swap input/inputs posição.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>move</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (from: number, to: number) => void\n            </code>\n          </td>\n          <td>\n            Move input/inputs em outra posição.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> A diferença entre{\" \"}\n              <code>move</code> e <code>swap</code>, é que chamando{\" \"}\n              <code>move</code> vai empurrar os campos em um loop , enquanto{\" \"}\n              <code>swap</code> somente muda a posição de dois campos.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>remove</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (index?: number | number[]) => void\n            </code>\n          </td>\n          <td>\n            Remove campos de uma posição particular, ou remove todos quando\n            nenhum índice é fornecido.\n          </td>\n        </tr>\n      </>\n    ),\n  },\n  validationResolver: {\n    title: \"validationResolver\",\n    description: (\n      <>\n        <p>\n          Essa função permite executar qualquer validação ou metodo externo,\n          como\n          <a\n            href=\"https://github.com/hapijs/joi\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Joi\n          </a>\n          ,{\" \"}\n          <a\n            href=\"https://github.com/ianstormtaylor/superstruct\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Superstruct\n          </a>{\" \"}\n          e etc. Fato é que, o objetivo é não se limitar ao Yup como nosso\n          schema externo. Nós gostariamos de suportar muitas outras bibliotecas\n          de validação para funcionar com o React Hook Form. Você pode inclusive\n          escrever sua propria logica de validação.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Tenha certeza que você\n          retornando o objeto que contem <code>values</code> e{\" \"}\n          <code>errors</code>, e seus valores padrão sejam um objeto vazio{\" \"}\n          <code>{`{}`}</code>.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> retornar a chave do\n          objeto que contenha os erros é relevante para seus inputs.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Essa função será\n          cacheada dentro do custom hook, similar ao{\" \"}\n          <code>validationSchema</code>, enquanto o{\" \"}\n          <code>validationContext</code> é um objeto mutável que pode ser\n          modificado a cada re-render.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Nota:</b> Revalidar o input vai\n          ocorrer somente em um campo por vez durante as interações do usuário,\n          porque a biblioteca em si vai considerar o objeto do campo em\n          especifico e disparará o re-render de acordo.\n        </p>\n      </>\n    ),\n  },\n}\n","import * as React from \"react\"\nimport Layout from \"../../components/layout\"\nimport Seo from \"../../components/seo\"\nimport ApiPage from \"../../components/ApiPage\"\nimport api from \"../../data/pt/api-v5\"\n\nconst ApiPT = ({\n  location,\n}: {\n  location: {\n    search: string\n    pathname: string\n  }\n}) => (\n  <Layout location={location} defaultLang={\"pt\"}>\n    <Seo title={api.title} location={location} />\n    <ApiPage defaultLang=\"pt\" />\n  </Layout>\n)\n\nexport default ApiPT\n"],"sourceRoot":""}