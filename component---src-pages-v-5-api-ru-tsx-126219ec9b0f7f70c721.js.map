{"version":3,"sources":["webpack:///./src/data/ru/api-v5.tsx","webpack:///./src/pages/v5/api.ru.tsx"],"names":["Popup","typographyStyles","note","colors","lightPink","buttonStyles","links","codeBlock","CodeArea","useFieldArrayArgument","typeText","Api","location","defaultLang","title","api","ApiPage"],"mappings":"mPASe,EACN,sBAQH,WA4BA,WAgBA,WAYA,WAOA,WAKA,WAyEUA,EAAA,EAWV,WAOkBC,IAAiBC,KAgCnC,WAUkBD,IAAiBC,KAUnC,WAUkBD,IAAiBC,KAYNC,IAAOC,UAMrBC,IAAaC,MAiE1B,WAiBF,WAIkBL,IAAiBC,KAwBnC,WA8CA,WAaA,WA2BE,WAoBF,WAMqBD,IAAiBM,UAKpBN,IAAiBC,KAKdD,IAAiBM,UAkDtC,WAMkBN,IAAiBC,KAiCnC,WA4BkBD,IAAiBC,KAenC,WA6BA,WAGkBD,IAAiBC,KAepBG,IAAaC,MAc5B,WAiBGE,EAAA,EAAkBC,IAGHR,IAAiBC,KA8B5BM,EAAA,EAwCP,WAMuBP,IAAiBS,SAOlBT,IAAiBC,KAgBdD,IAAiBS,SAajBT,IAAiBS,SAajBT,IAAiBS,SAajBT,IAAiBS,SAajBT,IAAiBS,SAQpBT,IAAiBC,KAadD,IAAiBS,SAsBnBT,IAAiBS,SAUjBT,IAAiBS,SAejBT,IAAiBS,SAajBT,IAAiBS,SAQlBT,IAAiBC,KAKjBD,IAAiBC,KAYhBD,IAAiBS,SAYjBT,IAAiBS,SAYjCF,EAAA,EAYgBP,IAAiBS,SAcjBT,IAAiBS,SA2BjBT,IAAiBS,SAcjBT,IAAiBS,SAaxC,WAoDA,WAIqBT,IAAiBS,SAIpBT,IAAiBC,KA+BZD,IAAiBS,SAUjBT,IAAiBS,SAajBT,IAAiBS,SAUjBT,IAAiBS,SAejBT,IAAiBS,SAgBlBT,IAAiBC,KAWvC,WAQkBD,IAAiBC,KASnC,WA0BkBD,IAAiBC,KAOjBD,IAAiBC,KAKjBD,IAAiBC,KAOjBD,IAAiBC,KCvvC1BS,UAdH,SAAC,GAAD,IACVC,EADU,EACVA,SADU,OAQV,gBAAC,IAAD,CAAQA,SAAUA,EAAUC,YAAY,MACtC,gBAAC,IAAD,CAAKC,MAAOC,EAAWH,SAAUA,IACjC,gBAACI,EAAA,EAAD,CAASH,YAAY","file":"component---src-pages-v-5-api-ru-tsx-126219ec9b0f7f70c721.js","sourcesContent":["import * as React from \"react\"\nimport colors from \"../../styles/colors\"\nimport Popup from \"../../components/Popup\"\nimport CodeArea from \"../../components/CodeArea\"\nimport useFieldArrayArgument from \"../../components/codeExamples/useFieldArrayArgument\"\nimport typographyStyles from \"../../styles/typography.module.css\"\nimport buttonStyles from \"../../styles/button.module.css\"\nimport code from \"../../components/codeExamples/defaultExample\"\n\nexport default {\n  title: \"Документация по API\",\n  header: {\n    description:\n      \"сфокусирован на предоставлении лучшего опыта разработки за счет упрощения API.\",\n  },\n  useForm: {\n    title: \"useForm\",\n    intro: (\n      <>\n        Вызывая <code>useForm</code>, вы получите следующие методы{\" \"}\n      </>\n    ),\n    description: (\n      <p>\n        <code>useForm</code> также имеет <b>необязательные</b> аргументы. В\n        следующем примере приведены значения по умолчанию для всех параметров.\n      </p>\n    ),\n    validationResolver: (goToSection) => (\n      <>\n        <p>\n          This callback function allow you to run through any schema or custom\n          validation. The function has the entire form <code>values</code> as\n          argument, and you will need to validate the result and return both{\" \"}\n          <code>values</code> and <code>errors</code>. Read more at{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"validationResolver\")}\n          >\n            validationResolver\n          </button>{\" \"}\n          section.\n        </p>\n      </>\n    ),\n    validateContext: (\n      <>\n        <p>\n          This context object will be injected into{\" \"}\n          <code>validationResolver</code>'s second argument or{\" \"}\n          <a\n            href=\"https://github.com/jquense/yup\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Yup\n          </a>{\" \"}\n          validation's context object.\n        </p>\n      </>\n    ),\n    validateCriteriaMode: (\n      <>\n        <p>\n          <code>firstError</code> - значение по умолчанию, будут проверены все\n          валидируемые поля и собраны все первоначальные ошибки.\n        </p>\n        <p>\n          Если для данного параметра установлено значение <code>all</code>, то\n          будет выполнена проверка всех полей и собраны все обнаруженные ошибки.\n        </p>\n      </>\n    ),\n    validateOnSubmit: (\n      <>\n        Валидация будет выполнена по событию <code>submit</code> и всем\n        невалидным полям будет добавлен обработчик на событие{\" \"}\n        <code>onChange</code> для повторной валидации.\n      </>\n    ),\n    validateOnBlur: (\n      <>\n        Валидация будет выполнена по событию <code>blur</code>.\n      </>\n    ),\n    validateOnChange: (\n      <>\n        Валидация будет выполнена по событию <code>change</code> для каждого\n        поля, и это приведёт к массовым перерисовкам. Не рекомендуется:\n        считается, что это ухудшает производительность.\n      </>\n    ),\n    defaultValues: (goToSection) => (\n      <>\n        <p>\n          Вы можете установить зачение по умолчанию для поля с помощью{\" \"}\n          <code>defaultValue/defaultChecked</code>{\" \"}\n          <a\n            className={buttonStyles.links}\n            href=\"https://reactjs.org/docs/uncontrolled-components.html\"\n          >\n            (узнать больше из доки по React о Default Values)\n          </a>{\" \"}\n          или передать <code>defaultValues</code> в качестве необязального\n          параметра для заполнения значений по умолчанию для всей формы.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>defaultValues</code> is cached within the custom hook, if you\n          want to reset <code>defaultValues</code> please use{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"reset\")}\n          >\n            reset\n          </button>{\" \"}\n          api.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Значение,\n          определённое в <code>defaultValues</code> будет добавлено в{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"watch\")}\n          >\n            watch\n          </button>{\" \"}\n          в качестве <code>defaultValue</code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b>{\" \"}\n          <code>defaultValues</code> не заполняется автоматически при\n          регистрации вручную (например:{\" \"}\n          <code>{`register({ name: 'test' })`}</code>) потому что поле,\n          <code>зарегистрированное</code> вручную, не передаёт <code>ref</code>{\" \"}\n          в React Hook Form.\n        </p>\n      </>\n    ),\n    validationSchema: (goToSection) => (\n      <p>\n        Применение правил валидации с <code>Yup</code> на уровне схемы,\n        перейдите в раздел{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"validationSchema\")}\n        >\n          validationSchema\n        </button>{\" \"}\n        .\n      </p>\n    ),\n    reValidateMode: (\n      <p>\n        Этот параметр позволяет установить, когда поля с ошибками будут повторно\n        валидироваться (по умолчанию проверка запускается при любом изменении в\n        поле). <Popup />\n      </p>\n    ),\n    validationFields: (\n      <p>\n        Предоставление массива полей означает, что будут проверены только\n        добавленные в массив поля. Эта опция полезна, когда вы хотите\n        переключать, какие поля требуются для проверки.\n      </p>\n    ),\n    submitFocusError: (\n      <>\n        <p>\n          По умолчанию, когда пользователь отправляет форму и она содержит\n          ошибку, первое поле с ошибкой будет в фокусе.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Только\n          зарегистрированные поля с <code>ref</code> будут работать. Поля,\n          зарегистрированные вручную, работать не будут. например:{\" \"}\n          <code>{`register({ name: 'test' }) // не работает`}</code>{\" \"}\n        </p>\n      </>\n    ),\n    nativeValidation: (goToSection) => (\n      <p>\n        Устанавливая эту опцию в <code>true</code> включит нативную браузерную\n        валидацию. Вы можете{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation\"\n        >\n          узнать больше о браузерной валидации\n        </a>\n        , и перейти в раздел{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"nativeValidation\")}\n        >\n          nativeValidation\n        </button>{\" \"}\n        , где приведено больше деталей и примеров.\n      </p>\n    ),\n  },\n  unregister: {\n    title: \"unregister\",\n    description: (\n      <>\n        <p>\n          Этот метод позволяет вам отменить регистрацию -{\" \"}\n          <code>unregister</code>\n          единичных полей или массива полей. Это удобно, если вы\n          зарегистрировали поле внутри <code>useEffect</code> в качестве\n          кастомной регистрации и вам нужно отменить регистрацию после\n          отключения (unmount) компонента.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Когда вы\n          регистрируете поле, его значение больше не будет включено в данные\n          формы, которые будут отправляться.\n        </p>\n      </>\n    ),\n  },\n  register: {\n    title: \"register\",\n    description: (\n      <>\n        <p>\n          Этот метод позволяет регистрировать input/select <code>Ref</code> и\n          правила их валидации в React Hook Form.\n        </p>\n        <p>\n          Правила валидации основаны на HTML стандарте и также позволяют\n          добавлять кастомную валидацию.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Важно:</b> параметр{\" \"}\n          <code>name</code> - <b>обязательный</b> и <b>уникальный</b>. Имя поля\n          также поддерживает \"dot and bracket syntax\", который даёт вам\n          возможность создавать вложенные поля формы. Форма с примером приведена\n          ниже:\n        </p>\n      </>\n    ),\n    fieldArray: (\n      <p\n        style={{\n          paddingLeft: 10,\n          borderLeft: `4px solid ${colors.lightPink}`,\n        }}\n      >\n        Если вы работаете с <code>массивом/массивами полей</code>, вы можете\n        задать имя поля как <code>name[index]</code>.{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/react-hook-form/react-hook-form/blob/master/examples/FieldArray.tsx\"\n          title=\"пример массива полей\"\n        >\n          Посмотреть пример с массивом полей\n        </a>\n        .\n      </p>\n    ),\n    example: \"Результат отправки формы\",\n    selectHelp:\n      \"При выборе способа регистрации, таблица API, приведенная ниже, будет обновлена.\",\n    options: {\n      title: \"Register Options\",\n      registerWithValidation: \"Регистрация с валидацией\",\n      registerWithValidationMessage:\n        \"Регистрация с валидацией и сообщением об ошибке\",\n      note: (goToSection) => (\n        <>\n          <h2 className={typographyStyles.title}>Кастомная регистрация</h2>\n          <p>\n            Вы также можете зарегистрировать поля вручную, что может быть удобно\n            при работе с кастомными компонентами, когда <code>Ref</code>{\" \"}\n            неприменим. Это также актуально, когда вы работаете с React Native с\n            такими кастомными компонентами как{\" \"}\n            <a\n              href=\"https://github.com/JedWatson/react-select\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              react-select\n            </a>\n            .\n          </p>\n\n          <p>\n            При использовании вызова кастомной регистрации, вам нужно обновить\n            значение поля с помощью{\" \"}\n            <button\n              className={buttonStyles.codeAsLink}\n              onClick={() => goToSection(\"setValue\")}\n            >\n              setValue\n            </button>\n            , потому что поле больше не является зарегистрированным с помощью\n            его ref.\n          </p>\n\n          <p>\n            <code\n              className={typographyStyles.codeBlock}\n            >{`register({ name: 'firstName' }, { required: true, min: 8 })`}</code>\n          </p>\n\n          <p>\n            <b className={typographyStyles.note}>Примечание:</b> Если вы хотите,\n            чтобы регистрация кастомного поля вызывала повторный рендеринг после\n            обновления его значения, то вам нужно указать тип\n            зарегистрированного поля.\n          </p>\n        </>\n      ),\n    },\n    validation: {\n      required: (\n        <>\n          Булевые \"правдивые\" значения указывают на то, что поле должно иметь\n          значение перед отправкой формы. Вы также можете указать строку с\n          текстом ошибки для объекта ошибки (<code>errors</code> object).\n        </>\n      ),\n      maxLength: \"Максимальная разрешённая длинна поля.\",\n      minLength: \"Минимальная разрешённая длинна поля.\",\n      max: \"Максимальное разрешённое значение для данного поля.\",\n      min: \"Минимальное разрешённое значение для данного поля.\",\n      pattern: \"Шаблон regex для данного поля\",\n      validate: `Вы можете передать функцию обратного вызова в качестве аргумента для валидации или передать объект функций обратного вызова для проверки всех из них (см. примеры)`,\n    },\n  },\n  formState: {\n    title: \"formState\",\n    description: (\n      <>\n        <p>Этот объект содержит информацию о состоянии формы.</p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>formState</code> is wrapped with{\" \"}\n          <a\n            href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Proxy\n          </a>{\" \"}\n          to improve render performance, so make you have invoke/read it before\n          <code>render</code> in order to enable the state update. Этот Функция\n          уменьшения количества повторного рендеринга применима только к\n          веб-платформе из-за отсутствия поддержки <code>Proxy</code> в React\n          Native.\n        </p>\n      </>\n    ),\n    dirty: \"Устанавливается в true после изменения любого поля.\",\n    dirtyFields: \"Уникальный набор пользовательских полей.\",\n    isSubmitted:\n      \"Устанавливается в true после отправки формы. После отправки формы ее состояние будет оставаться до тех пор, пока не будет вызван метод сброса.\",\n    touched:\n      \"Объект, содержаций все поля, с которыми взаимодействовал пользователь.\",\n    isSubmitting: (\n      <>\n        Во время отправки формы будет выставлено в <code>true</code> и после\n        отправки будет выставлено в <code>false</code>\n      </>\n    ),\n    submitCount: \"Количество отправлений формы.\",\n    isValid: \"Устанавливается в true, если нет ошибок.\",\n  },\n  errors: {\n    title: \"errors\",\n    description: () => (\n      <>\n        <p>\n          Объект, содержащий ошибки формы или сообщения об ошибках для каждого\n          поля.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Есть развница в\n          V3 и V4:\n        </p>\n\n        <ul>\n          <li>\n            <p>V4: Вложеный объект</p>\n            <p>\n              <strong>Причина:</strong> так как опциональный чейнинг становится\n              всё более популярным в сообществе и для поддержки лучшего типа.\n            </p>\n            <p>\n              <code>{`errors?.yourDetail?.firstName;`}</code>\n            </p>\n          </li>\n          <li>\n            <p>V3: Плоский объект</p>\n            <p>\n              <strong>Причина:</strong> простой доступ к ошибке.\n            </p>\n            <p>\n              <code>{`errors['yourDetail.firstName'];`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    types: (\n      <>\n        Это полезно для проверки входных данных, таких как правила пароля,\n        которые должны возвращать несколько ошибок для одного поля. Чтобы\n        включить эту функцию, убедитесь, что вы установили{\" \"}\n        <code>validateCriteriaMode: 'all'</code>.\n      </>\n    ),\n    message: `Сообщение является пустой строкой по умолчанию. Однако, если вы зарегистрируете валидацию с сообщением об ошибке, то затем она будет возвращена.`,\n    ref: `Ссылка на ваш элемент поля.`,\n  },\n  watch: {\n    title: \"watch\",\n    description: (\n      <>\n        <p>\n          Будет следить за выбранным полем/полями и вернёт его/их значение(я).\n          Это может быть удобно для определениятого того, что нужно рендерить.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              Когда <code>defaultValue</code> не определено, первый рендер\n              вернёт <code>undefined</code> из <code>watch</code> потому, что он\n              вызывается раньше <code>регистрации</code>, но вы можете задать{\" \"}\n              <code>defaultValue</code> вторым аргументом.\n            </p>\n          </li>\n          <li>\n            <p>\n              Однако, если <code>defaultValues</code> было инициализировано в{\" \"}\n              <code>useForm</code> в качестве аргумента, то 1-й рендер вернёт\n              значение, указанное в качесте <code>defaultValues</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    tableTitle: {\n      single: (\n        <>\n          Наблюдение за полем по имени (как и функция{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noreferrer noopener\"\n            href=\"https://lodash.com/docs/4.17.15#get\"\n          >\n            get\n          </a>{\" \"}\n          в lodash)\n        </>\n      ),\n      multiple: \"Наблюдение за несколькими полями\",\n      all: \"Наблюдение за всеми полями\",\n      nest: \"Наблюдение за всеми полями и возврат вложенного объекта\",\n    },\n  },\n  handleSubmit: {\n    title: \"handleSubmit\",\n    description: (\n      <>\n        <p>\n          Эта функция будет передавать данные формы, когда валидация формы\n          прошла успешно и может быть вызван удаленно.\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(onSubmit)()\n          </code>\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Вы можете\n          использовать <code>async</code> функцию для асинхронной валидации,\n          например:{\" \"}\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(async (data) => await fetchAPI(data))\n          </code>\n        </p>\n      </>\n    ),\n  },\n  reset: (goToSection) => ({\n    title: \"reset\",\n    description: (\n      <>\n        <p>\n          Эта функция сбрасывает значения полей и ошибки формы. Поставив{\" \"}\n          <code> omitResetState </code>, вы можете свободно только сбросить\n          конкретный кусок состояния. Вы можете передать <code>values</code> в\n          качестве необязательного аргумента для сброса формы в присвоенные\n          значения по умолчанию.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Для\n          контролируемых компонентов, например <code>React-Select</code>, у\n          которых нет значения <code>ref</code>, вы должны сбрасывать значение\n          вручную с помощью{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"setValue\")}\n          >\n            setValue\n          </button>{\" \"}\n          или использовать{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"Controller\")}\n          >\n            Controller\n          </button>{\" \"}\n          в качестве обёртки для вашего контролируемого компонента.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> Вам нужно будет\n          укажите <code> defaultValues ​​</code> во время <code> useForm </code>\n          или<code> reset </code> со значением для сброса\n          <code> Controller </code>стоимость компонентов.\n        </p>\n      </>\n    ),\n  }),\n  setError: {\n    title: \"setError\",\n    description: (\n      <>\n        <p>\n          Эта функция даёт возможность вручную установать одну или несколько\n          ошибок.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> этот метод не\n          сохранит ошибку и заблокирует отправить действие. Это более полезно во\n          время функции <code>handleSubmit</code>, когда Вы хотите отправить\n          сообщение об ошибке пользователям после асинхронной проверки.\n        </p>\n      </>\n    ),\n  },\n  clearError: {\n    title: \"clearError\",\n    description: (\n      <ul>\n        <li>\n          <p>\n            <code>undefined</code>: сбрасывает все ошибки\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string</code>: сбрасывает одну ошибку\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string[]</code>: сбрасывает массив ошибок\n          </p>\n        </li>\n      </ul>\n    ),\n  },\n  setValue: {\n    title: \"setValue\",\n    description: (\n      <>\n        <p>\n          Эта функция позволяет динамически устанавливать значение для\n          input/select. В то же время она пытается избежать повторного\n          рендеринга, когда в этом нет необходимости, и только следующие условия\n          вызовут повторный рендеринг.\n        </p>\n        <ul>\n          <li>\n            <p>Когда ошибка вызывается при обновлении значения поля</p>\n          </li>\n          <li>\n            <p>Когда ошибка исправляется при обновлении значения поля</p>\n          </li>\n          <li>\n            <p>\n              Когда setValue вызван впервые и formState параметр{\" \"}\n              <code>dirty</code> установлен в true\n            </p>\n          </li>\n          <li>\n            <p>\n              Когда вызван setValue и обновлено значение свойства{\" \"}\n              <code>touched</code> из formState\n            </p>\n          </li>\n        </ul>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> При вызове этого\n          метода, <code>formState</code> добавит <code>имя</code> поля в массив{\" \"}\n          <code>touched</code>.\n        </p>\n        <p>\n          Также вы можете установать <code>shouldValidate</code> в{\" \"}\n          <code>true</code>и это вызовет валидацию поля, например:{\" \"}\n          <code>setValue('name', 'value', true)</code>\n        </p>\n      </>\n    ),\n  },\n  getValues: {\n    title: \"getValues\",\n    description: (\n      <>\n        <p>\n          Эта функция возвращает все данные формы, и это полезно, когда вы\n          хотите получить значения полей формы.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              По умолчанию <code>getValues()</code> вернёт значения полей формы\n              в виде плоской структуры, например:{\" \"}\n              <code>{`{ test: 'data', test1: 'data1'}`}</code>\n            </p>\n          </li>\n          <li>\n            <p>\n              При работе с определёнными полями формы,{\" \"}\n              <code>getValues({`{ nest: true }`})</code> вернёт данные во\n              вложенной структуре согласно <code>имени</code> поля, например:{\" \"}\n              <code>{`{ test: [1, 2], test1: { data: '23' } }`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n  },\n  triggerValidation: {\n    title: \"triggerValidation\",\n    description: (\n      <>\n        <p>Для принудительного вызова валидации input/select полей формы.</p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> При неудачной\n          валидации, объект <code>errors</code> будет обновлён.\n        </p>\n      </>\n    ),\n  },\n  validationSchema: {\n    title: \"validationSchema\",\n    description: (\n      <p>\n        Если вы хотите централизовать свои правила валидации с помощью внешней\n        схемы валидации, то вы можете использовать <code>validationSchema</code>{\" \"}\n        в <code>useForm</code> в качестве необязательного параметра. React Hook\n        Form в настоящий момент поддерживает{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/jquense/yup\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Yup\n        </a>{\" \"}\n        в качестве внешнего объекта схемы валидации.\n      </p>\n    ),\n  },\n  useFieldArray: {\n    title: \"useFieldArray\",\n    description: (\n      <>\n        <p>\n          A custom hook for working with uncontrolled Field Arrays (dynamic\n          inputs). The motivation behind this hook is to provide better user\n          experience and form performance. You can watch{\" \"}\n          <a\n            href=\"https://www.youtube.com/watch?v=Q7lrHuUfgIs\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            this short video\n          </a>{\" \"}\n          to compare controlled vs uncontrolled Field Array.\n        </p>\n\n        <p>This hook provides the following object and functions.</p>\n\n        <CodeArea rawData={useFieldArrayArgument} />\n\n        <p>\n          <b className={typographyStyles.note}>Important: </b>{\" \"}\n          <code>useFieldArray</code> is built on top of uncontrolled components.\n          The following notes will help you aware and be mindful of its\n          behaviour during implementation.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              you can populate the <code>fields</code> by supply{\" \"}\n              <code>defaultValues</code> at <code>useForm</code> hook.\n            </p>\n          </li>\n          <li>\n            <p>\n              make sure you assign <code>id</code> from <code>fields</code>{\" \"}\n              object as your component key.\n            </p>\n          </li>\n          <li>\n            <p>\n              set <code>defaultValue</code> when you want to set default value\n              or reset with inputs.\n            </p>\n          </li>\n          <li>\n            <p>\n              you can not call actions one after another. Actions need to be\n              triggered per render.\n            </p>\n            <CodeArea\n              withOutCopy\n              rawData={`// ❌ The following is not correct\nhandleChange={() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n  append({ test: 'test' });\n}}\n\n// ✅ The following is correct and second action is triggered after next render\nhandleChange={() => {\n  append({ test: 'test' });\n}}\n\nReact.useEffect(() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n}, fields)\n            `}\n            />\n          </li>\n          <li>\n            It's <strong>important</strong> to apply{\" \"}\n            <code>{`ref={register()}`}</code> instead of{\" \"}\n            <code>{`ref={register}`}</code> when working with{\" \"}\n            <code>useFieldArray</code> so <code>register</code> will get invoked\n            during <code>map</code>.\n          </li>\n          <li>\n            <p>\n              Он не работает с пользовательским регистром в{\" \"}\n              <code>useEffect</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    table: (\n      <>\n        <tr>\n          <td>\n            <code>fields</code>\n          </td>\n          <td width={320}>\n            <code className={typographyStyles.typeText}>\n              object & {`{ id: string }`}\n            </code>\n          </td>\n          <td>\n            This object is the source of truth to map and render inputs.\n            <p>\n              <b className={typographyStyles.note}>Important: </b> because each\n              inputs can be uncontrolled, <code>id</code> is required with\n              mapped components to help React identify which items have changed,\n              are added, or are removed.\n            </p>\n            <p>\n              eg: <code>{`{fields.map(d => <input key={d.id} />)}`}</code>\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>append</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (obj: object | object[]) => void\n              </code>\n            </code>\n          </td>\n          <td>Append input/inputs to the end of your fields</td>\n        </tr>\n        <tr>\n          <td>\n            <code>prepend</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (obj: object | object[]) => void\n              </code>\n            </code>\n          </td>\n          <td>Prepend input/inputs to the start of your fields</td>\n        </tr>\n        <tr>\n          <td>\n            <code>insert</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (index: number, value: object) => void\n              </code>\n            </code>\n          </td>\n          <td>Insert input/inputs at particular position.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>swap</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (from: number, to: number) => void\n              </code>\n            </code>\n          </td>\n          <td>Swap input/inputs position.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>move</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (from: number, to: number) => void\n              </code>\n            </code>\n          </td>\n          <td>\n            Move input/inputs to another position.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> difference between{\" \"}\n              <code>move</code> and <code>swap</code>, keep calling{\" \"}\n              <code>move</code> will push input/inputs in a loop, while{\" \"}\n              <code>swap</code> only change two input/inputs' position.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>remove</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (index?: number | number[]) => void\n              </code>\n            </code>\n          </td>\n          <td>\n            Remove input/inputs at particular position, or remove all when no\n            index is provided.\n          </td>\n        </tr>\n      </>\n    ),\n  },\n  Controller: {\n    title: \"Controller\",\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>Уникальное имя вашего поля.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td>✓</td>\n          <td>\n            Контролируемый компонент, например: <code>as=\"input\"</code> или{\" \"}\n            <code>{`as={<TextInput />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>control</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td />\n          <td>\n            <code>control</code> объект - это вызов формой <code>useForm</code>.\n            Это необязательно, если вы используете FormContext.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>defaultValue</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>any</code>\n          </td>\n          <td />\n          <td>\n            То же, что и <code>defaultValue</code> неконтролируемого компонента,\n            когда указывается <code>логическое</code> значение. Будет\n            обрабатываться как чекбокс.\n            <p>\n              <b className={typographyStyles.note}>Примечание:</b> вам нужно\n              задать или атрибут поля <code>defaultValue</code> или{\" \"}\n              <code>defaultValues</code> для <code>useForm</code>\n            </p>\n            <p>\n              <b className={typographyStyles.note}>Note</b>: if your form will\n              invoke <code>reset</code> with different values, you will need to\n              provide <code>defaultValues</code> at useForm level instead of set\n              inline <code>defaultValue</code>.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>rules</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td />\n          <td>\n            Валидационные правила в соответствии с <code>register</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChange</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (args: any | EventTarget) => any\n            </code>\n          </td>\n          <td />\n          <td>\n            Параметр <code>onChange</code> позволяет вам изменять возвращаемое\n            значение, убедитесь, что вы знаете форму реквизита{\" \"}\n            <code>value</code> внешнего компонента. Атрибут <code>value</code>{\" \"}\n            или <code>checked</code> будет считываться, когда форма полезных\n            данных представляет собой <code>object</code>, который содержит\n            атрибут type.\n            <CodeArea\n              withOutCopy\n              rawData={`onChange={{([ event ]) => event.target.value}}\nonChange={{([ event, data ]) => ({ checked: data.checked})}}`}\n            />\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChangeName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td />\n          <td>\n            Этот параметр позволяет вам настроить таргетинг на конкретное имя\n            события, например: когда событие <code>onChange</code> называется{\" \"}\n            <code>onTextChange</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onFocus</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>() => void</code>\n          </td>\n          <td></td>\n          <td>\n            <p>\n              Этот обратный вызов позволяет пользовательскому хуку\n              сосредоточиться на вводе, когда есть ошибка. Эта функция применима\n              как для React, так и для Реагируйте-нативные компоненты, пока они\n              могут быть сфокусированы.\n            </p>\n            <p>\n              <a\n                href=\"https://codesandbox.io/s/react-hook-form-controller-auto-focus-5tru5\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                Вот рабочий пример.\n              </a>\n              .\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onBlurName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td />\n          <td>\n            Этот параметр позволяет вам настроить таргетинг на конкретное имя\n            события, например: когда событие <code>onBlur</code> называется{\" \"}\n            <code>onTextBlur</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>valueName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td />\n          <td>\n            Этот параметр позволяет переопределять свойство <code>value</code> и\n            поддерживает другие компоненты, которые не используют свойство{\" \"}\n            <code>value</code>, например: <code>checked</code>,{\" \"}\n            <code>selected</code> и т.д.\n          </td>\n        </tr>\n      </tbody>\n    ),\n    description: (\n      <>\n        <p>\n          React Hook Form принимает неконтролируемые компоненты и нативные поля,\n          однако трудно избежать работы с внешним контролируемым компонентом,\n          таким как{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/JedWatson/react-select\"\n          >\n            React-Select\n          </a>\n          ,{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/ant-design/ant-design\"\n          >\n            AntD\n          </a>{\" \"}\n          и{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://material-ui.com/\"\n          >\n            Material-UI\n          </a>\n          . Этот компонент-обёртка сделает вашу жизнь проще при работе с ними.\n        </p>\n        <p>\n          Каждый параметр, который вы передаёте в компонет Controller, будет\n          передан в экземпляр компонента, который вы указали в параметре{\" \"}\n          <code>as</code>. Например, представьте что у вас есть кастомный{\" \"}\n          <code>Switch</code>, с обязательным свойством - <code>label</code>. Вы\n          можете передать это свойство в Controller напрямую. Свойство{\" \"}\n          <code>name</code> будет использовано позже для доступа к значению\n          этого свойства внутри формы.\n        </p>\n      </>\n    ),\n  },\n  useFormContext: {\n    title: \"useFormContext\",\n    introduction: (\n      <p>\n        Контекст формы предназначен для решения проблемы, когда в дереве\n        компонентов есть глубоко вложенные поля, а методы передаются вглубь как{\" \"}\n        <code>props</code>.\n      </p>\n    ),\n    description: (\n      <>\n        <p>\n          Как только ваша форма обёрнута в <code>FormContext</code>, то{\" \"}\n          <code>useFormContext</code>:{\" \"}\n          <code className={typographyStyles.typeText}>function</code> может быть\n          вызвана внутри вложенного компонента.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Примечание:</b> вызов{\" \"}\n          <code>useFormContext</code> вернёт все функции из <code>useForm</code>\n          .\n        </p>\n      </>\n    ),\n  },\n  control: {\n    title: \"control\",\n    description: (\n      <p>\n        Этот объект создан для компонента Controller из React Hook Form, который\n        содержит методы для регистрации управляемого компонента в React Hook\n        Form.\n      </p>\n    ),\n  },\n  ErrorMessage: {\n    title: \"ErrorMessage\",\n    description: (\n      <p>\n        Простой компонент для отображения связанного сообщения об ошибке поля.\n      </p>\n    ),\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>имя связанного поля.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>errors</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>object</code>\n          </td>\n          <td />\n          <td>\n            <code>errors</code> объект из React Hook Form. Необязательно, если\n            вы используете FormContext.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>message</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>встроенное сообщение об ошибке.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td />\n          <td>\n            Компонент-обёртка или HTML тэг. Например: <code>as=\"span\"</code> или{\" \"}\n            <code>{`as={<Text />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>children</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              ({`{ message: string, messages?: string[]}`}) => any\n            </code>\n          </td>\n          <td />\n          <td>\n            Это{\" \"}\n            <a\n              href=\"https://reactjs.org/docs/render-props.html\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              render prop\n            </a>{\" \"}\n            сообщения об ошибке/ошибках.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> you need to set{\" \"}\n              validateCriteriaMode to 'all' for using <code>messages</code>.\n            </p>\n          </td>\n        </tr>\n      </tbody>\n    ),\n  },\n  NativeValidation: {\n    title: \"Browser built-in validation\",\n    description: (\n      <>\n        <p>\n          В следующем примере показано, как вы можете использовать браузерную\n          валидацию. Вам нужно установить свойство <code>nativeValidation</code>{\" \"}\n          в <code>true</code>, а остальная часть синтаксиса такая же, как для\n          стандартной валидации.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note</b>: This feature has been\n          removed in V4 due to low usage, but you can still use it in V3\n        </p>\n      </>\n    ),\n  },\n  validationResolver: {\n    title: \"validationResolver\",\n    description: (\n      <>\n        <p>\n          This function allow you to run any external validation methods, such\n          as{\" \"}\n          <a\n            href=\"https://github.com/hapijs/joi\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Joi\n          </a>\n          ,{\" \"}\n          <a\n            href=\"https://github.com/ianstormtaylor/superstruct\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Superstruct\n          </a>{\" \"}\n          and etc. In fact, the goal is not only limited Yup as our external\n          (schema) validation library. We would like to support many other\n          validation libraries to work with React Hook Form. You can even write\n          your custom validation logic to validate.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> make sure you are\n          returning object which contains <code>values</code> and{\" \"}\n          <code>errors</code>, and their default value should be empty object{\" \"}\n          <code>{`{}`}</code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> returning errors\n          object's key should be relevant to your inputs.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> this function will be\n          cached inside the custom hook similar as <code>validationSchema</code>\n          , while <code>validationContext</code> is a mutable object which can\n          be changed on each re-render.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> re-validate input will\n          only occur one field at time during user’s interaction, because the\n          lib itself will evaluate the error object to the specific field and\n          trigger re-render accordingly.\n        </p>\n      </>\n    ),\n  },\n}\n","import * as React from \"react\"\nimport Layout from \"../../components/layout\"\nimport Seo from \"../../components/seo\"\nimport ApiPage from \"../../components/ApiPage\"\nimport api from \"../../data/ru/api-v5\"\n\nconst Api = ({\n  location,\n}: {\n  location: {\n    search: string\n    pathname: string\n  }\n}) => (\n  <Layout location={location} defaultLang=\"ru\">\n    <Seo title={api.title} location={location} />\n    <ApiPage defaultLang=\"ru\" />\n  </Layout>\n)\n\nexport default Api\n"],"sourceRoot":""}