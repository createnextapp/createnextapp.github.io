{"version":3,"sources":["webpack:///./src/data/en/api-v5.tsx","webpack:///./src/pages/v5/api.en.tsx"],"names":["Popup","typographyStyles","note","colors","lightPink","buttonStyles","links","codeBlock","CodeArea","useFieldArrayArgument","typeText","Api","location","defaultLang","title","api","ApiPage"],"mappings":"mPASe,EACN,oBAOH,WAWA,WAkCA,WAgBA,WAOA,WAKA,WAwEYA,EAAA,EAWZ,WAOkBC,IAAiBC,KA+BnC,WAQkBD,IAAiBC,KAUnC,WAUkBD,IAAiBC,KAWNC,IAAOC,UAMrBC,IAAaC,MA+D1B,WAiBF,WAIkBL,IAAiBC,KAuBnC,WA8CA,WAcA,WA2BE,WAoBF,WAMqBD,IAAiBM,UAKpBN,IAAiBC,KAIdD,IAAiBM,UAiDtC,WAGkBN,IAAiBC,KAiCnC,WA+BkBD,IAAiBC,KAgBnC,WA6BA,WAGkBD,IAAiBC,KAcpBG,IAAaC,MAc5B,WAiBGE,EAAA,EAAkBC,IAGHR,IAAiBC,KA+B5BM,EAAA,EAyCP,WAMuBP,IAAiBS,SAOlBT,IAAiBC,KAgBdD,IAAiBS,SAajBT,IAAiBS,SAajBT,IAAiBS,SAajBT,IAAiBS,SAajBT,IAAiBS,SAQpBT,IAAiBC,KAadD,IAAiBS,SAsBnBT,IAAiBS,SAUjBT,IAAiBS,SAgBjBT,IAAiBS,SAajBT,IAAiBS,SAQlBT,IAAiBC,KAKjBD,IAAiBC,KAYhBD,IAAiBS,SAYjBT,IAAiBS,SAWjCF,EAAA,EAYgBP,IAAiBS,SAcjBT,IAAiBS,SA2BjBT,IAAiBS,SAcjBT,IAAiBS,SAYxC,WA8CA,WAegBT,IAAiBC,KA4BVD,IAAiBS,SAUjBT,IAAiBS,SAajBT,IAAiBS,SAUjBT,IAAiBS,SAejBT,IAAiBS,SAgBlBT,IAAiBC,KAWvC,WAQkBD,IAAiBC,KASnC,WA0BkBD,IAAiBC,KAOjBD,IAAiBC,KAKjBD,IAAiBC,KAOjBD,IAAiBC,KCjvC1BS,UAdH,SAAC,GAAD,IACVC,EADU,EACVA,SADU,OAQV,gBAAC,IAAD,CAAQA,SAAUA,EAAUC,YAAY,MACtC,gBAAC,IAAD,CAAKC,MAAOC,EAAWH,SAAUA,IACjC,gBAACI,EAAA,EAAD,CAASH,YAAY","file":"component---src-pages-v-5-api-en-tsx-e054fe046ba959576c92.js","sourcesContent":["import * as React from \"react\"\nimport colors from \"../../styles/colors\"\nimport Popup from \"../../components/Popup\"\nimport CodeArea from \"../../components/CodeArea\"\nimport useFieldArrayArgument from \"../../components/codeExamples/useFieldArrayArgument\"\nimport typographyStyles from \"../../styles/typography.module.css\"\nimport buttonStyles from \"../../styles/button.module.css\"\nimport code from \"../../components/codeExamples/defaultExample\"\n\nexport default {\n  title: \"API Documentation\",\n  header: {\n    description: \"focuses on providing the best DX by simplifying the API.\",\n  },\n  useForm: {\n    title: \"useForm\",\n    intro: (\n      <>\n        By invoking <code>useForm</code>, you will receive the following methods{\" \"}\n      </>\n    ),\n    description: (\n      <p>\n        <code>useForm</code> also has <b>optional</b> arguments. The following\n        example demonstrates all options' default value.\n      </p>\n    ),\n    validateCriteriaMode: (\n      <>\n        <p>\n          When set to <code>firstError</code> (default), only first error from\n          each field will be gathered.\n        </p>\n        <p>\n          When set to <code>all</code>, all errors from each field will be\n          gathered.\n        </p>\n      </>\n    ),\n    validationResolver: (goToSection) => (\n      <>\n        <p>\n          This callback function allows you to run through any schema or custom\n          validation. The function has the entire form <code>values</code> as\n          argument, and you will need to validate the result and return both{\" \"}\n          <code>values</code> and <code>errors</code>. Read more at{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"validationResolver\")}\n          >\n            validationResolver\n          </button>{\" \"}\n          section.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> This function will be\n          cached inside the hook, you will have to either move the function\n          outside of the component or memorise the function.\n        </p>\n      </>\n    ),\n    validateContext: (\n      <>\n        <p>\n          This context object will be injected into{\" \"}\n          <code>validationResolver</code>'s second argument or{\" \"}\n          <a\n            href=\"https://github.com/jquense/yup\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Yup\n          </a>{\" \"}\n          validation's context object.\n        </p>\n      </>\n    ),\n    validateOnSubmit: (\n      <>\n        Validation will trigger on the <code>submit</code> event and invalid\n        inputs will attach <code>onChange</code> event listeners to re-validate\n        them.\n      </>\n    ),\n    validateOnBlur: (\n      <>\n        Validation will trigger on the <code>blur</code> event.\n      </>\n    ),\n    validateOnChange: (\n      <>\n        Validation will trigger on the <code>change</code> event with each\n        input, and lead to multiple re-renders. Warning: this often comes with a\n        significant impact on performances.\n      </>\n    ),\n    defaultValues: (goToSection) => (\n      <>\n        <p>\n          You can set the input's default value with{\" \"}\n          <code>defaultValue/defaultChecked</code>{\" \"}\n          <a\n            className={buttonStyles.links}\n            href=\"https://reactjs.org/docs/uncontrolled-components.html\"\n          >\n            (read more from the React doc for Default Values)\n          </a>{\" \"}\n          or pass <code>defaultValues</code> as an optional argument to populate\n          default values for the entire form.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>defaultValues</code> is cached within the custom hook, if you\n          want to reset <code>defaultValues</code> please use{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"reset\")}\n          >\n            reset\n          </button>{\" \"}\n          api.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> Values defined in{\" \"}\n          <code>defaultValues</code> will be injected into{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"watch\")}\n          >\n            watch\n          </button>{\" \"}\n          as <code>defaultValue</code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b>{\" \"}\n          <code>defaultValues</code> doesn't auto populate with the manually\n          registered input (eg: <code>{`register({ name: 'test' })`}</code>)\n          because the manual <code>register</code> field does not provide the{\" \"}\n          <code>ref</code> to React Hook Form.\n        </p>\n      </>\n    ),\n    validationSchema: (goToSection) => (\n      <p>\n        Apply form validation rules with <code>Yup</code> at the schema level,\n        please refer to the{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"validationSchema\")}\n        >\n          validationSchema\n        </button>{\" \"}\n        section.\n      </p>\n    ),\n    reValidateMode: (\n      <p>\n        This option allows you to configure when inputs with errors get\n        re-validated (by default, validation is triggered during an input\n        change.) <Popup />\n      </p>\n    ),\n    validationFields: (\n      <p>\n        Providing an array of fields means only included fields will be\n        validated. This option is useful when you want to toggle which fields\n        are required to validate.\n      </p>\n    ),\n    submitFocusError: (\n      <>\n        <p>\n          When set to true (default) and the user submits a form that fails the\n          validation, it will set focus on the first field with an error.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> Only registered fields\n          with a <code>ref</code> will work. Manually registered inputs won't\n          work. eg: <code>{`register({ name: 'test' }) // doesn't work`}</code>{\" \"}\n        </p>\n      </>\n    ),\n    nativeValidation: (goToSection) => (\n      <p>\n        Setting this option to <code>true</code> will enable the browser's\n        native validation. You can{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation\"\n        >\n          find out more about the built-in browser validation\n        </a>\n        , and refer to the{\" \"}\n        <button\n          className={buttonStyles.codeAsLink}\n          onClick={() => goToSection(\"nativeValidation\")}\n        >\n          nativeValidation\n        </button>{\" \"}\n        section for more details and examples.\n      </p>\n    ),\n  },\n  unregister: {\n    title: \"unregister\",\n    description: (\n      <>\n        <p>\n          This method will allow you to <code>unregister</code> a single input\n          or an array of inputs. This is useful when you used a custom register\n          in <code>useEffect</code> and want to unregister it when the component\n          unmounts.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> When you unregister an\n          input, its value will no longer be included in the form data that gets\n          submitted.\n        </p>\n      </>\n    ),\n  },\n  register: {\n    title: \"register\",\n    description: (\n      <>\n        <p>\n          This method allows you to register input/select <code>Ref</code> and\n          validation rules into React Hook Form.\n        </p>\n        <p>\n          Validation rules are all based on HTML standard and also allow custom\n          validation.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Important:</b> <code>name</code>{\" \"}\n          is <b>required</b> and <b>unique</b>. Input name also supports dot and\n          bracket syntax, which allows you to easily create nested form fields.\n          Example table is below:\n        </p>\n      </>\n    ),\n    fieldArray: (\n      <p\n        style={{\n          paddingLeft: 10,\n          borderLeft: `4px solid ${colors.lightPink}`,\n        }}\n      >\n        If you working on <code>arrays/array fields</code>, you can assign an\n        input name as <code>name[index]</code>.{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/react-hook-form/react-hook-form/blob/master/examples/FieldArray.tsx\"\n          title=\"example for Field Array\"\n        >\n          Check out the Field Array example\n        </a>\n        .\n      </p>\n    ),\n    example: \"Submit Result\",\n    selectHelp:\n      \"By selecting the register option, the API table below will get updated.\",\n    options: {\n      title: \"Register Options\",\n      registerWithValidation: \"Register with validation\",\n      registerWithValidationMessage:\n        \"Register with validation and error message\",\n      note: (goToSection) => (\n        <>\n          <h2 className={typographyStyles.title}>Custom Register</h2>\n          <p>\n            You can also register inputs manually, which is useful when working\n            with custom components and <code>Ref</code> is not accessible. This\n            is actually the case when you are working with React Native or\n            custom component like{\" \"}\n            <a\n              href=\"https://github.com/JedWatson/react-select\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              react-select\n            </a>\n            .\n          </p>\n\n          <p>\n            By using a custom register call, you will need to update the input\n            value with{\" \"}\n            <button\n              className={buttonStyles.codeAsLink}\n              onClick={() => goToSection(\"setValue\")}\n            >\n              setValue\n            </button>\n            , because input is no longer registered with its ref.\n          </p>\n\n          <p>\n            <code\n              className={typographyStyles.codeBlock}\n            >{`register({ name: 'firstName' }, { required: true, min: 8 })`}</code>\n          </p>\n\n          <p>\n            <b className={typographyStyles.note}>Note:</b> If you want the\n            custom registered input to trigger a re-render during its value\n            update, then you should give a type to your registered input.\n          </p>\n        </>\n      ),\n    },\n    validation: {\n      required: (\n        <>\n          A Boolean which, if true, indicates that the input must have a value\n          before the form can be submitted. You can assign a string to return an\n          error message in the <code>errors</code> object.\n        </>\n      ),\n      maxLength: \"The maximum length of the value to accept for this input.\",\n      minLength: \"The minimum length of the value to accept for this input.\",\n      max: \"The maximum value to accept for this input.\",\n      min: \"The minimum value to accept for this input.\",\n      pattern: \"The regex pattern for the input.\",\n      validate: `You can pass a callback function as the argument to validate, or you can pass an object of callback functions to validate all of them. (refer to the examples)`,\n    },\n  },\n  formState: {\n    title: \"formState\",\n    description: (\n      <>\n        <p>This object contain information about the form state.</p>\n\n        <p>\n          <b className={typographyStyles.note}>Important:</b>{\" \"}\n          <code>formState</code> is wrapped with{\" \"}\n          <a\n            href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Proxy\n          </a>{\" \"}\n          to improve render performance, so make sure you invoke or read it\n          before <code>render</code> in order to enable the state update. This\n          reduces re-render feature only applies to the Web platform due to a\n          lack of support on Proxy at React Native.\n        </p>\n      </>\n    ),\n    dirty: \"Set to true after a user interacted with any of the inputs.\",\n    isSubmitted:\n      \"Set true after a user submitted the form. After a form's submission, its' state will remain submitted until invoked with reset method.\",\n    dirtyFields: \"A unique set of user modified fields.\",\n    touched:\n      \"An object containing all the inputs the user has interacted with.\",\n    isSubmitting: (\n      <>\n        <code>true</code> if the form is currently being submitted.{\" \"}\n        <code>false</code> otherwise.\n      </>\n    ),\n    submitCount: \"Number of times the form was submitted.\",\n    isValid: \"Set to true if the form doesn't have any error.\",\n  },\n  errors: {\n    title: \"errors\",\n    description: (currentLanguage) => (\n      <>\n        <p>\n          Object containing form errors and error messages corresponding to each\n          input.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> Difference between V3\n          and V4:\n        </p>\n\n        <ul>\n          <li>\n            <p>V4: Nested objects</p>\n            <p>\n              <strong>Reason:</strong> optional chaining is getting widely\n              adopted and allows better support for types..\n            </p>\n            <p>\n              <code>{`errors?.yourDetail?.firstName;`}</code>\n            </p>\n          </li>\n          <li>\n            <p>V3: Flatten object</p>\n            <p>\n              <strong>Reason:</strong> simple and easy to access error.\n            </p>\n            <p>\n              <code>{`errors['yourDetail.firstName'];`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    types: (\n      <>\n        This is useful when you want to return all validation errors for a\n        single input. For instance, a password field that is required to have a\n        minimum length AND contain a special character. Note that you need to\n        set <code>validateCriteriaMode</code> to\n        <code>'all'</code> for this option to work properly.\n      </>\n    ),\n    message: `If you registered your input with an error message, then it will be put in this field. Otherwise it's an empty string by default.`,\n    ref: `Reference for your input element.`,\n  },\n  watch: {\n    title: \"watch\",\n    description: (\n      <>\n        <p>\n          This will watch specified inputs and return their values. It is useful\n          for determining what to render.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              When <code>defaultValue</code> is not defined, the first render of{\" \"}\n              <code>watch</code> will return <code>undefined</code> because it\n              is called before <code>register</code>, but you can set the{\" \"}\n              <code>defaultValue</code> as the second argument to return value.\n            </p>\n          </li>\n          <li>\n            <p>\n              However, if <code>defaultValues</code> was initialised in{\" \"}\n              <code>useForm</code> as argument, then the first render will\n              return what's provided in <code>defaultValues</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    tableTitle: {\n      single: (\n        <>\n          Watch input value by name (similar to lodash{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noreferrer noopener\"\n            href=\"https://lodash.com/docs/4.17.15#get\"\n          >\n            get\n          </a>{\" \"}\n          function)\n        </>\n      ),\n      multiple: \"Watch multiple inputs\",\n      all: \"Watch all inputs\",\n      nest: \"Watch all inputs and return nested object\",\n    },\n  },\n  handleSubmit: {\n    title: \"handleSubmit\",\n    description: (\n      <>\n        <p>\n          This function will pass the form data when form validation is\n          successful and can be invoked remotely as well.\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(onSubmit)()\n          </code>\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> You can pass an{\" \"}\n          <code>async</code> function for asynchronous validation. eg:{\" \"}\n        </p>\n        <p>\n          <code className={typographyStyles.codeBlock}>\n            handleSubmit(async (data) => await fetchAPI(data))\n          </code>\n        </p>\n      </>\n    ),\n  },\n  reset: (goToSection) => ({\n    title: \"reset\",\n    description: (\n      <>\n        <p>\n          This function will reset the fields' values and errors within the\n          form. By supply <code>omitResetState</code>, you have the freedom to\n          only reset specific piece of state. You can pass <code>values</code>{\" \"}\n          as an optional argument to reset your form into assigned default\n          values.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> For controlled\n          components like <code>React-Select</code> which don't expose{\" \"}\n          <code>ref</code>, you will have to reset the input value manually\n          through{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"setValue\")}\n          >\n            setValue\n          </button>{\" \"}\n          or using{\" \"}\n          <button\n            className={buttonStyles.codeAsLink}\n            onClick={() => goToSection(\"Controller\")}\n          >\n            Controller\n          </button>{\" \"}\n          to wrap around your controlled component.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note: </b> You will need to\n          supply <code>defaultValues</code> at <code>useForm</code> to{\" \"}\n          <code>reset</code> <code>Controller</code> components' value.\n        </p>\n      </>\n    ),\n  }),\n  setError: {\n    title: \"setError\",\n    description: (\n      <>\n        <p>The function allows you to manually set one or multiple errors.</p>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> This method will not\n          persist the error and block the submit action. It's more useful during{\" \"}\n          <code>handleSubmit</code> function when you want to give error\n          feedback to the users after async validation.\n        </p>\n      </>\n    ),\n  },\n  clearError: {\n    title: \"clearError\",\n    description: (\n      <ul>\n        <li>\n          <p>\n            <code>undefined</code>: reset all errors\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string</code>: reset single error\n          </p>\n        </li>\n        <li>\n          <p>\n            <code>string[]</code>: reset multiple errors\n          </p>\n        </li>\n      </ul>\n    ),\n  },\n  setValue: {\n    title: \"setValue\",\n    description: (\n      <>\n        <p>\n          This function allows you to dynamically set{\" \"}\n          <strong>\n            <code>registered</code>\n          </strong>{\" \"}\n          input/select value. At the same time, it tries to avoid re-rendering\n          when it's not necessary. Only the following conditions will trigger a\n          re-render:\n        </p>\n        <ul>\n          <li>\n            <p>When an error is triggered by a value update</p>\n          </li>\n          <li>\n            <p>When an error is corrected by a value update</p>\n          </li>\n          <li>\n            <p>\n              When setValue is invoked for the first time and formState{\" \"}\n              <code>dirty</code> is set to true\n            </p>\n          </li>\n          <li>\n            <p>\n              When setValue is invoked and formState <code>touched</code> is\n              updated\n            </p>\n          </li>\n        </ul>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> By invoking this\n          method, <code>formState</code> will set the input to{\" \"}\n          <code>touched</code>.\n        </p>\n        <p>\n          You can also set the <code>shouldValidate</code> parameter to{\" \"}\n          <code>true</code>\n          in order to trigger a field validation. eg:{\" \"}\n          <code>setValue('name', 'value', true)</code>\n        </p>\n      </>\n    ),\n  },\n  getValues: {\n    title: \"getValues\",\n    description: (\n      <>\n        <p>\n          This function will return the entire form data, and it's useful when\n          you want to retrieve form values.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              By default <code>getValues()</code> will return form data in a\n              flat structure. eg:{\" \"}\n              <code>{`{ test: 'data', test1: 'data1'}`}</code>\n            </p>\n          </li>\n          <li>\n            <p>\n              Working on the defined form fields,{\" \"}\n              <code>getValues({`{ nest: true }`})</code> will return data in a\n              nested structure according to input <code>name</code>. eg:{\" \"}\n              <code>{`{ test: [1, 2], test1: { data: '23' } }`}</code>\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n  },\n  triggerValidation: {\n    title: \"triggerValidation\",\n    description: (\n      <>\n        <p>To manually trigger an input/select validation in the form.</p>\n        <p>\n          <b className={typographyStyles.note}>Note:</b> When validation fails,\n          the <code>errors</code> object will be updated.\n        </p>\n      </>\n    ),\n  },\n  validationSchema: {\n    title: \"validationSchema\",\n    description: (\n      <p>\n        If you would like to centralize your validation rules as an external\n        validation schema, you can use the <code>validationSchema</code>{\" \"}\n        parameter. React Hook Form currently supports{\" \"}\n        <a\n          className={buttonStyles.links}\n          href=\"https://github.com/jquense/yup\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Yup\n        </a>{\" \"}\n        for object schema validation.\n      </p>\n    ),\n  },\n  useFieldArray: {\n    title: \"useFieldArray\",\n    description: (\n      <>\n        <p>\n          A custom hook for working with uncontrolled Field Arrays (dynamic\n          inputs). The motivation behind this hook is to provide better user\n          experience and form performance. You can watch{\" \"}\n          <a\n            href=\"https://www.youtube.com/watch?v=Q7lrHuUfgIs\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            this short video\n          </a>{\" \"}\n          to compare controlled vs uncontrolled Field Array.\n        </p>\n\n        <p>This hook provides the following object and functions.</p>\n\n        <CodeArea rawData={useFieldArrayArgument} />\n\n        <p>\n          <b className={typographyStyles.note}>Important: </b>{\" \"}\n          <code>useFieldArray</code> is built on top of uncontrolled components.\n          The following notes will help you aware and be mindful of its\n          behaviour during implementation.\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              you can populate the <code>fields</code> by supply{\" \"}\n              <code>defaultValues</code> at <code>useForm</code> hook.\n            </p>\n          </li>\n          <li>\n            <p>\n              make sure you assign <code>id</code> from <code>fields</code>{\" \"}\n              object as your component key.\n            </p>\n          </li>\n          <li>\n            <p>\n              make sure to set <code>defaultValue</code> to{\" \"}\n              <code>fields[index]</code> when you want to set default value,\n              remove or reset with inputs.\n            </p>\n          </li>\n          <li>\n            <p>\n              you can not call actions one after another. Actions need to be\n              triggered per render.\n            </p>\n            <CodeArea\n              withOutCopy\n              rawData={`// ❌ The following is not correct\nhandleChange={() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n  append({ test: 'test' });\n}}\n\n// ✅ The following is correct and second action is triggered after next render\nhandleChange={() => {\n  append({ test: 'test' });\n}}\n\nReact.useEffect(() => {\n  if (fields.length === 2) {\n    remove(0);\n  }\n}, fields)\n            `}\n            />\n          </li>\n          <li>\n            <p>\n              It's <strong>important</strong> to apply{\" \"}\n              <code>{`ref={register()}`}</code> instead of{\" \"}\n              <code>{`ref={register}`}</code> when working with{\" \"}\n              <code>useFieldArray</code> so <code>register</code> will get\n              invoked during <code>map</code>.\n            </p>\n          </li>\n          <li>\n            <p>\n              It doesn't work with custom register at <code>useEffect</code>.\n            </p>\n          </li>\n        </ul>\n      </>\n    ),\n    table: (\n      <>\n        <tr>\n          <td>\n            <code>fields</code>\n          </td>\n          <td width={320}>\n            <code className={typographyStyles.typeText}>\n              object & {`{ id: string }`}\n            </code>\n          </td>\n          <td>\n            This object is the source of truth to map and render inputs.\n            <p>\n              <b className={typographyStyles.note}>Important: </b> because each\n              inputs can be uncontrolled, <code>id</code> is required with\n              mapped components to help React identify which items have changed,\n              are added, or are removed.\n            </p>\n            <p>\n              eg: <code>{`{fields.map(d => <input key={d.id} />)}`}</code>\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>append</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (obj: object | object[]) => void\n              </code>\n            </code>\n          </td>\n          <td>Append input/inputs to the end of your fields</td>\n        </tr>\n        <tr>\n          <td>\n            <code>prepend</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (obj: object | object[]) => void\n              </code>\n            </code>\n          </td>\n          <td>Prepend input/inputs to the start of your fields</td>\n        </tr>\n        <tr>\n          <td>\n            <code>insert</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (index: number, value: object) => void\n              </code>\n            </code>\n          </td>\n          <td>Insert input/inputs at particular position.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>swap</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (from: number, to: number) => void\n              </code>\n            </code>\n          </td>\n          <td>Swap input/inputs position.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>move</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (from: number, to: number) => void\n              </code>\n            </code>\n          </td>\n          <td>\n            Move input/inputs to another position.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> difference between{\" \"}\n              <code>move</code> and <code>swap</code>, keep calling{\" \"}\n              <code>move</code> will push input/inputs in a circle, while{\" \"}\n              <code>swap</code> only change two input/inputs' position.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>remove</code>\n          </td>\n          <td>\n            <code>\n              <code className={typographyStyles.typeText}>\n                (index?: number | number[]) => void\n              </code>\n            </code>\n          </td>\n          <td>\n            Remove input/inputs at particular position, or remove all when no\n            index is provided.\n          </td>\n        </tr>\n      </>\n    ),\n  },\n  Controller: {\n    title: \"Controller\",\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>Unique name of your input.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td>✓</td>\n          <td>\n            Controlled component. eg: <code>as=\"input\"</code>,{\" \"}\n            <code>{`as={<TextInput />}`}</code> or{\" \"}\n            <code>{`as={TextInput}`}</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>control</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td></td>\n          <td>\n            <code>control</code> object is from invoking <code>useForm</code>.\n            it's optional if you are using FormContext.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>defaultValue</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>any</code>\n          </td>\n          <td></td>\n          <td>\n            The same as uncontrolled component's <code>defaultValue</code>, when\n            supply <code>boolean</code> value, it will be treated as checkbox\n            input.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> you will need to\n              supply either <code>defaultValue</code> or{\" \"}\n              <code>defaultValues</code> at <code>useForm</code>\n            </p>\n            <p>\n              <b className={typographyStyles.note}>Note</b>: if your form will\n              invoke <code>reset</code> with default values, you will need to\n              provide <code>defaultValues</code> at useForm level instead of set\n              inline <code>defaultValue</code>.\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>rules</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>Object</code>\n          </td>\n          <td></td>\n          <td>\n            Validation rules according to <code>register</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChange</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              (args: any | EventTarget) => any\n            </code>\n          </td>\n          <td></td>\n          <td>\n            This prop allows you to customize the return value, make sure you\n            aware the shape of the external component <code>value</code> props.{\" \"}\n            <code>value</code> or <code>checked</code> attribute will be read\n            when payload's shape is an <code>object</code> which contains{\" \"}\n            <code>type</code> attribute.\n            <CodeArea\n              withOutCopy\n              rawData={`onChange={{([ event ]) => event.target.value}}\nonChange={{([ { checked } ]) => ({ checked })}}`}\n            />\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onChangeName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            This prop allows you to target a specific event name for{\" \"}\n            <code>onChange</code>, eg: when <code>onChange</code> event is named{\" \"}\n            <code>onTextChange</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onFocus</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>() => void</code>\n          </td>\n          <td></td>\n          <td>\n            <p>\n              This callback allows the custom hook to focus on the input when\n              there is an error. This function is applicable for both React and\n              React-Native components as long as they can be focused.\n            </p>\n            <p>\n              Here is a{\" \"}\n              <a\n                href=\"https://codesandbox.io/s/react-hook-form-controller-auto-focus-5tru5\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                working example with MUI\n              </a>\n              .\n            </p>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>onBlurName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            This prop allows you to target a specific event name for{\" \"}\n            <code>onBlur</code>, eg: when <code>onBlur</code> event is named{\" \"}\n            <code>onTextBlur</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>valueName</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>\n            This prop allows you to support inputs that doesn't use a prop\n            called <code>value</code>. eg: <code>checked</code>,{\" \"}\n            <code>selected</code> and etc.\n          </td>\n        </tr>\n      </tbody>\n    ),\n    description: (\n      <>\n        <p>\n          React Hook Form embraces uncontrolled components and native inputs,\n          however it's hard to avoid working with external controlled component\n          such as{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/JedWatson/react-select\"\n          >\n            React-Select\n          </a>\n          ,{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://github.com/ant-design/ant-design\"\n          >\n            AntD\n          </a>{\" \"}\n          and{\" \"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href=\"https://material-ui.com/\"\n          >\n            Material-UI\n          </a>\n          . This wrapper component will make it easier for you to work with\n          them.\n        </p>\n        <p>\n          Every prop you pass to the Controller component will be forwarded to\n          the component instance you provided with the <code>as</code> prop. For\n          instance, if you have a custom <code>Switch</code> component that\n          requires a <code>label</code> prop, you can pass it to the Controller\n          component directly and it will take care of forwarding the prop for\n          you. The <code>name</code> prop will be used mainly to access the\n          value through the form later.\n        </p>\n      </>\n    ),\n  },\n  useFormContext: {\n    title: \"useFormContext\",\n    introduction: (\n      <>\n        <p>\n          Hook function that allows you to access the form context.{\" \"}\n          <code>useFormContext</code> is intended to be used in deeply nested\n          structures, where it would become inconvenient to pass the context as\n          a prop.\n        </p>\n        <p>\n          You need to wrap your form with the <code>FormContext</code> provider\n          component for <code>useFormContext</code> to work properly.\n        </p>\n      </>\n    ),\n    description: (\n      <p>\n        <b className={typographyStyles.note}>Note:</b> invoking{\" \"}\n        <code>useFormContext</code> will give you all of the{\" \"}\n        <code>useForm</code> hook functions.\n      </p>\n    ),\n  },\n  control: {\n    title: \"control\",\n    description: (\n      <p>\n        This object is made for React Hook Form's Controller component, which\n        contains methods for registering controlled component into React Hook\n        Form.\n      </p>\n    ),\n  },\n  ErrorMessage: {\n    title: \"ErrorMessage\",\n    description: (\n      <p>A simple component to render associated input's error message.</p>\n    ),\n    table: (\n      <tbody>\n        <tr>\n          <td>\n            <code>name</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td>✓</td>\n          <td>associated field name.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>errors</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>object</code>\n          </td>\n          <td></td>\n          <td>\n            <code>errors</code> object from React Hook Form. It's optional if\n            you are using <code>FormContext</code>.\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>message</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>string</code>\n          </td>\n          <td></td>\n          <td>inline error message.</td>\n        </tr>\n        <tr>\n          <td>\n            <code>as</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              React.ElementType | string\n            </code>\n          </td>\n          <td></td>\n          <td>\n            Wrapper component or HTML tag. eg: <code>as=\"span\"</code> or{\" \"}\n            <code>{`as={<Text />}`}</code>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <code>children</code>\n          </td>\n          <td>\n            <code className={typographyStyles.typeText}>\n              ({`{ message: string, messages?: string[]}`}) => any\n            </code>\n          </td>\n          <td></td>\n          <td>\n            This is a{\" \"}\n            <a\n              href=\"https://reactjs.org/docs/render-props.html\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              render prop\n            </a>{\" \"}\n            for rendering error message or messages.\n            <p>\n              <b className={typographyStyles.note}>Note:</b> you need to set{\" \"}\n              validateCriteriaMode to 'all' for using <code>messages</code>.\n            </p>\n          </td>\n        </tr>\n      </tbody>\n    ),\n  },\n  NativeValidation: {\n    title: \"Browser built-in validation\",\n    description: (\n      <>\n        <p>\n          The following example demonstrates how you can leverage the browser's\n          validation. You only need to set <code>nativeValidation</code> to{\" \"}\n          <code>true</code> and the rest of the syntax is the same as standard\n          validation.\n        </p>\n        <p>\n          <b className={typographyStyles.note}>Note</b>: This feature has been\n          removed in V4 due to low usage, but you can still use it in V3\n        </p>\n      </>\n    ),\n  },\n  validationResolver: {\n    title: \"validationResolver\",\n    description: (\n      <>\n        <p>\n          This function allow you to run any external validation methods, such\n          as{\" \"}\n          <a\n            href=\"https://github.com/hapijs/joi\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Joi\n          </a>\n          ,{\" \"}\n          <a\n            href=\"https://github.com/ianstormtaylor/superstruct\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Superstruct\n          </a>{\" \"}\n          and etc. In fact, the goal is not only limited Yup as our external\n          (schema) validation library. We would like to support many other\n          validation libraries to work with React Hook Form. You can even write\n          your custom validation logic to validate.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> make sure you are\n          returning object which contains <code>values</code> and{\" \"}\n          <code>errors</code>, and their default value should be{\" \"}\n          <code>{`{}`}</code>.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> returning errors\n          object's key should be relevant to your inputs.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> this function will be\n          cached inside the custom hook similar as <code>validationSchema</code>\n          , while <code>validationContext</code> is a mutable object which can\n          be changed on each re-render.\n        </p>\n\n        <p>\n          <b className={typographyStyles.note}>Note:</b> re-validate input will\n          only occur one field at time during user’s interaction, because the\n          lib itself will evaluate the error object to the specific field and\n          trigger re-render accordingly.\n        </p>\n      </>\n    ),\n  },\n}\n","import * as React from \"react\"\nimport Layout from \"../../components/layout\"\nimport Seo from \"../../components/seo\"\nimport ApiPage from \"../../components/ApiPage\"\nimport api from \"../../data/en/api-v5\"\n\nconst Api = ({\n  location,\n}: {\n  location: {\n    search: string\n    pathname: string\n  }\n}) => (\n  <Layout location={location} defaultLang=\"en\">\n    <Seo title={api.title} location={location} />\n    <ApiPage defaultLang=\"en\" />\n  </Layout>\n)\n\nexport default Api\n"],"sourceRoot":""}